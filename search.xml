<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BIO|NIO|AIO的区别</title>
    <url>/2023/08/28/BIO-NIO-AIO%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[
  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>IO模型</p>

    </div>
    <div class="notel-content">
      <p><strong>IO模型</strong>指的是在网络数据传输过程中，使用什么通道去发送和接收数据，我们常见的有BIO、NIO、AIO(NIO2.0)</p>

    </div>
  </div>

<h2 id="同步-异步-阻塞-非阻塞-到底是什么意思？"><a href="#同步-异步-阻塞-非阻塞-到底是什么意思？" class="headerlink" title="同步&#x2F;异步&#x2F;阻塞&#x2F;非阻塞 到底是什么意思？"></a>同步&#x2F;异步&#x2F;阻塞&#x2F;非阻塞 到底是什么意思？</h2><ul>
<li><p><strong>同步&#x2F;异步</strong> 指的是你去调用一个方法，如果这个方法是同步的，那么你就会等待这个方法执行结束后才能执行后续操作；如果是异步的话，他会立即给你返回，但是这个不是真实的结果，真实的结果它是通过消息机制通知你或者回调机制通知你的。</p>
</li>
<li><p><strong>阻塞&#x2F;非阻塞</strong> 阻塞指的是当你去调用一个获取洗衣机信息方法的时候，如果这个时候没有洗衣机，那么方法就会一直阻塞，直到能查询到洗衣机的信息才会返回结果；非阻塞指的是当你调用一个获取洗衣机信息方法的时候，如果当时没有查到信息，你不会一直阻塞在那里，你这时可以去做别的事，但是你会时不时的去检查下是否有结果，然后再阻塞获取下，但是这不会影响你做其它事。</p>
</li>
</ul>
<div class="tabs" id="tab-lanmu1"><ul class="nav-tabs"><li class="tab active"><a class="#lanmu1-1">BIO(同步阻塞)</a></li><li class="tab"><a class="#lanmu1-2">NIO(同步非阻塞)</a></li><li class="tab"><a class="#lanmu1-3">AIO(异步非阻塞)</a></li></ul><div class="tab-content"><div class="tab-pane active" id="lanmu1-1"><p>我们经常使用的就是BIO，在我们学习编程基础javaSE的时候，应该都会学过socket通信，这里面使用的就是同步阻塞。以下是BIO的模型：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="D:\workspace\myblog\source_posts\BIO-NIO-AIO的区别.assets\640.webp"
                      alt="640"
                ></p>
<p>在BIO模型中，一个连接会对应一个处理线程，如果服务端使用单线程进行处理，后续连接将会一直阻塞；</p>
<ul>
<li><p>缺点：</p>
</li>
<li><ul>
<li>代码中的read,accept操作是阻塞操作，如果连接之后，服务端一直不发送数据，将会一直阻塞当前线程，浪费资源。</li>
<li>如果连接数很多，意味着创建的线程数量就会越来越多，会造成服务器压力太大，后续优化成线程池处理方式，勉强解决了此问题。</li>
</ul>
</li>
<li><p>应用场景 BIO适用于连接数较少且固定的架构，这种模式对服务器资源要求较高，但程序复杂度比较低；</p>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">package</span> com.example.netty.bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">9000</span>);</span><br><span class="line">        socket.getOutputStream().write(<span class="string">&quot;我是客户端&quot;</span>.getBytes());</span><br><span class="line">        socket.getOutputStream().flush();</span><br><span class="line">        System.out.println(<span class="string">&quot;向服务端发送数据结束&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> socket.getInputStream().read(bytes);</span><br><span class="line">            System.out.println(<span class="string">&quot;服务端发送过来的数据为：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="number">0</span>,read));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//服务端</span></span><br><span class="line"> <span class="keyword">package</span> com.example.netty.bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketServer</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ServerSocket serverSocket=<span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9000</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;等待连接&quot;</span>);</span><br><span class="line">            <span class="comment">// 阻塞等待</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;有客户端连接了&quot;</span>);</span><br><span class="line">            handleRead(client);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> client</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleRead</span><span class="params">(Socket client)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> client.getInputStream().read(bytes);</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端发送过来的数据为：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="number">0</span>,read));</span><br><span class="line"><span class="comment">//                    Thread.sleep(Integer.MAX_VALUE);</span></span><br><span class="line">                    client.getOutputStream().write(<span class="string">&quot;你好，我收到你的数据了&quot;</span>.getBytes());</span><br><span class="line">                    client.getOutputStream().flush();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="lanmu1-2"><p>NIO在BIO的基础上进行了升级，将阻塞换成非阻塞，虽然只是模式变了下，但是代码复杂量却增加了不少。在NIO模型中，服务端可以开启一个线程处理多个连接，它是非阻塞的，客户端发送的数据都会注册到多路复用器selector上面，当selector（selector的select方法是阻塞的）轮询到有读、写或者连接请求时，才会转发到后端程序进行处理，没有数据的时候，业务程序并不需要阻塞等待。</p>
<h3 id="NIO有三大组件：Channel-通道-、Buffer（缓存区）、Selector-选择器"><a href="#NIO有三大组件：Channel-通道-、Buffer（缓存区）、Selector-选择器" class="headerlink" title="NIO有三大组件：Channel(通道)、Buffer（缓存区）、Selector(选择器)"></a>NIO有三大组件：Channel(通道)、Buffer（缓存区）、Selector(选择器)</h3><ul>
<li>Channel 类似于流，但是它是一个双向的流，他是连接服务端和客户端的通道，不管是客户端还是服务端，都可以使用通道进行读写数据。</li>
<li>Buffer 它就是一个缓冲区，用来存放数据的载体，它借助通道，在客户端和服务端之间传递数据。</li>
<li>Selector 它对应一个或多个channel，客户端的连接都会注册到selector上面，然后由selector去调用后端处理程序</li>
</ul>
<h3 id="以下是NIO结构模型"><a href="#以下是NIO结构模型" class="headerlink" title="以下是NIO结构模型"></a>以下是NIO结构模型</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="D:\workspace\myblog\source_posts\BIO-NIO-AIO的区别.assets\640-1732783216506-5.webp"
                      alt="图片"
                ></h3><h3 id="NIO的非阻塞到底体现在哪里呢？"><a href="#NIO的非阻塞到底体现在哪里呢？" class="headerlink" title="NIO的非阻塞到底体现在哪里呢？"></a>NIO的非阻塞到底体现在哪里呢？</h3><p>看模型图大家有可能都知道，客户端所有的连接通道都会注册到selector上面，select会通过轮询去获取这些通道的状态，这些状态有accpet(连接请求)、READ读请求。</p>
<p>如果在轮询过程中发现已经有一个连接请求状态的话，这说明已经有一个客户端想要和服务端进行连接，直接把这个通道传给后端程序去处理连接操作；如果是在BIO模型下的话，会一直阻塞在accept上，直到有连接请求才会释放，继续执行后续的代码。</p>
<p>如果在轮询过程中发现已经有一个读请求状态的话，这说明已经有一个客户端把数据发送给服务端了，服务端可以直接把通道交给后端程序进行读操作的处理；如果是在BIO模型下的话，会一直阻塞的read上，直到有连接请求才会释放，继续执行后续的代码。</p>
<p><strong>「以上可以总结为：在NIO模型中，如果服务端执行了read操作的话，就说明已经有可用的数据进行读取了，如果执行了accpet操作的话，就说明此时一定有客户端发起了与服务端的连接，能够保证这种操作的前提是selector轮询到了可读可连接的通道状态。」</strong></p>
<h3 id="如果selector轮询后，得到了多个通道的read和accpet状态，NIO是如何处理的？"><a href="#如果selector轮询后，得到了多个通道的read和accpet状态，NIO是如何处理的？" class="headerlink" title="如果selector轮询后，得到了多个通道的read和accpet状态，NIO是如何处理的？"></a>如果selector轮询后，得到了多个通道的read和accpet状态，NIO是如何处理的？</h3><ul>
<li>单线程 如果在单线程模式下，处理方式是按照轮询后得到的变化的通道的先后顺序进行处理的，没错，它是同步进行处理的，也就是它只能处理完这个通道的操作，才能继续处理下个通道的请求，在selector代码中，是通过遍历所有有变化的通道进行处理的，后面大家看代码就明白了，这种一个selector对应一个线程的模式其实就是<strong>「redis的单线程IO模型」</strong>。</li>
<li>多线程 如果是在多线程模式下，selector在遍历每一个通道的时候，都会把对通道的操作交给一个线程去处理，一般都会丢到线程池中去处理，这个时候执行顺序就得看cpu的调度情况来决定了。</li>
</ul>
<p>接下来我们结合代码来整体看下NIO的工作机制</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.netty.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NioServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9000</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;等待事件发生&quot;</span>);</span><br><span class="line">            <span class="comment">// 这里还是阻塞等待，</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">select</span> <span class="operator">=</span> selector.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                handleChannel(selectionKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleChannel</span><span class="params">(SelectionKey selectionKey)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;有客户端发生了连接&quot;</span>);</span><br><span class="line">            <span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> channel.accept();</span><br><span class="line">                client.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                <span class="comment">// 连接之后立即注册读操作，客户端发送数据过来才能监听到</span></span><br><span class="line">                client.register(selectionKey.selector(), SelectionKey.OP_READ);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;收到客户端发送数据的请求&quot;</span>);</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) selectionKey.channel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果这里你不读取数据，读事件会一直触发，这是有NIO属于水平触发决定的，</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">allocate</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(allocate);</span><br><span class="line">                <span class="keyword">if</span> (read != -<span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端发送的数据:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(allocate.array(), <span class="number">0</span>, read));</span><br><span class="line">                &#125;</span><br><span class="line">                channel.write(ByteBuffer.wrap(<span class="string">&quot;你好，我是服务端&quot;</span>.getBytes()));</span><br><span class="line">                <span class="comment">// 处理完读操作之后，需要重新注册下读操作，</span></span><br><span class="line">                <span class="comment">// 如果下面一行被放开，将会一直会有可写操作触发，因为网络中99.999%的情况下都是可写的，一般不监听</span></span><br><span class="line"><span class="comment">//                selectionKey.interestOps(SelectionKey.OP_WRITE | SelectionKey.OP_READ);</span></span><br><span class="line">                selectionKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isWritable()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;触发写事件&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>服务端架构图</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="D:\workspace\myblog\source_posts\BIO-NIO-AIO的区别.assets\640-1732784150171-8.webp"
                      alt="图片"
                ></p>
<ul>
<li><p>服务端代码说明</p>
</li>
<li><ol>
<li>创建一个 ServerSocketChannel 和 Selector ，并将 ServerSocketChannel 注册到 Selector 上</li>
<li>selector 通过 select() 方法监听 channel 事件，当客户端连接时，selector 监听到连接事件， 获取到 ServerSocketChannel 注册时 绑定的 selectionKey</li>
<li>selectionKey 通过 channel() 方法可以获取绑定的 ServerSocketChannel</li>
<li>ServerSocketChannel 通过 accept() 方法得到 SocketChannel</li>
<li>将 SocketChannel 注册到 Selector 上，关心 read 事件</li>
<li>注册后返回一个 SelectionKey, 会和该 SocketChannel 关联</li>
<li>selector 继续通过 select() 方法监听事件，当客户端发送数据给服务端，selector 监听到read事件，获取到 SocketChannel 注册时 绑定的 selectionKey</li>
<li>selectionKey 通过 channel() 方法可以获取绑定的 socketChannel</li>
<li>将 socketChannel 里的数据读取出来</li>
<li>用 socketChannel 将服务端数据写回客户端</li>
</ol>
</li>
</ul>
<p>大家有可能注意到我在代码注释中提到的水平触发，我这做下解释：水平触发是多路复用中的一种模式，与此对应的还有一个边缘触发。</p>
<ul>
<li>水平触发 如果在通道中检测到数据变化后会触发通知，如果收到通知后，事件处理程序没有完全读取缓冲区中的所有数据或压根就没有读，那么在水平触发模式下，就会一直触发这个通知，直到缓冲区的内容被读取完，NIO中select和poll就属于这种模式</li>
<li>边缘触发 情况同上，不过是当系统通知一次之后，只有当通道中的数据再次发生改变后，才会再次发生通知。epoll既可以采用水平触发,也可以采用边缘触发</li>
</ul>
<p>客户端代码</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.netty.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NioClient</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">NioClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioClient</span>();</span><br><span class="line">        client.initClient(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9000</span>);</span><br><span class="line">        client.connect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 阻塞等待</span></span><br><span class="line">            selector.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                handler(selectionKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handler</span><span class="params">(SelectionKey selectionKey)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 收到服务端发送的数据</span></span><br><span class="line">        <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) selectionKey.channel();</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (len != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端收到信息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, len));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 连接事件发生</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isConnectable()) &#123;</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) selectionKey.channel();</span><br><span class="line">            <span class="comment">// 一般发起了连接后，会立即返回，需要使用isConnectionPending判断是否完成连接，如果正在连接，则调用finishConnect，如果不能连接则会抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (channel.isConnectionPending()) &#123;</span><br><span class="line">                channel.finishConnect();</span><br><span class="line">            &#125;</span><br><span class="line">            channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="string">&quot;你好，我是客户端&quot;</span>.getBytes());</span><br><span class="line">            channel.write(buffer);</span><br><span class="line">            selectionKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initClient</span><span class="params">(String s, <span class="type">int</span> i)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(s, i));</span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="多路复用常见的底层实现api"><a href="#多路复用常见的底层实现api" class="headerlink" title="多路复用常见的底层实现api"></a>多路复用常见的底层实现api</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="D:\workspace\myblog\source_posts\BIO-NIO-AIO的区别.assets\640-1732784307236-11.webp"
                      alt="图片"
                ></p>
<p>poll相比selelct，没有最大连接的限制；epoll相对于前两者，是一个不一样的机制，基于事件通知的方式，通知调用者；</p></div><div class="tab-pane" id="lanmu1-3"><p>异步非阻塞， 由操作系统完成后回调通知服务端程序启动线程去处理， 一般适用于连接数较多且连接时间较长的应用 应用场景：AIO方式适用于连接数目多且连接比较长（重操作） 的架构，JDK7 开始支持</p>
<ul>
<li>AIO代码示例：</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务端代码</span></span><br><span class="line">    <span class="keyword">package</span> com.example.netty.aio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AioServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">AsynchronousServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span></span><br><span class="line">                AsynchronousServerSocketChannel.open().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9000</span>));</span><br><span class="line">        serverChannel.accept(<span class="literal">null</span>,<span class="keyword">new</span>  <span class="title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Object&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(AsynchronousSocketChannel socketChannel, Object attachment)</span> &#123;</span><br><span class="line">                serverChannel.accept(attachment, <span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(socketChannel.getRemoteAddress());</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    socketChannel.read(buffer, buffer, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, result));</span><br><span class="line">                            socketChannel.write(ByteBuffer.wrap(<span class="string">&quot;HelloAioClient&quot;</span>.getBytes()));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, Object attachment)</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">package</span> com.example.netty.aio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AioClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException, IOException &#123;</span><br><span class="line">        <span class="type">AsynchronousSocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> AsynchronousSocketChannel.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9000</span>)).get();</span><br><span class="line">        socketChannel.write(ByteBuffer.wrap(<span class="string">&quot;HelloServer&quot;</span>.getBytes()));</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">len</span> <span class="operator">=</span> socketChannel.read(buffer).get();</span><br><span class="line">        <span class="keyword">if</span> (len!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端收到信息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div></div>

<p>「总结：可以看出异步非阻塞模式的代码是非常简单的，所有的操作都是通过回调机制触发的，我们只需要在回调方法中处理我们自己的逻辑就行了，其实AIO是基于NIO进行封装，后面会讲到netty也是基于NIO进行封装的」</p>
<h2 id="BIO、NIO、AIO区别"><a href="#BIO、NIO、AIO区别" class="headerlink" title="BIO、NIO、AIO区别"></a>BIO、NIO、AIO区别</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="D:\workspace\myblog\source_posts\BIO-NIO-AIO的区别.assets\640-1732784411947-14.webp"
                      alt="图片"
                ></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>欢迎来到我的博客</title>
    <url>/2023/08/26/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[
  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>自我介绍</p>

    </div>
    <div class="notel-content">
      <p>本人是一个技术上的小菜鸡，该博客只为记录自己的学习历程。</p>
<p>若发现笔记里面存在不对的地方，欢迎大家留言讨论。</p>
<p>最后，希望能和大家共同进步~</p>

    </div>
  </div>
]]></content>
  </entry>
</search>

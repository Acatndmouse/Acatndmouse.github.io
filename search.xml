<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Netty(一)：Netty的诞生以及简短的Netty案例</title>
    <url>/2023/08/29/Netty(%E4%B8%80)/</url>
    <content><![CDATA[<h1 id="为什么Netty-会诞生"><a href="#为什么Netty-会诞生" class="headerlink" title="为什么Netty 会诞生"></a>为什么Netty 会诞生</h1><p>为了解决NIO 编码复杂，但是又想使用NIO，所以netty来了，netty 通过对nio复杂的api进行了封装，使得netty在具备高性能、高吞吐量、低延迟的前提下，还能方便开发人员进行快速开发。</p>
<h1 id="有哪些使用场景"><a href="#有哪些使用场景" class="headerlink" title="有哪些使用场景"></a>有哪些使用场景</h1><h2 id="互联网行业"><a href="#互联网行业" class="headerlink" title="互联网行业"></a>互联网行业</h2><p>成为大多数中间件和rpc框架的底层通信组件，如dubbo、rocket mq</p>
<h2 id="游戏行业"><a href="#游戏行业" class="headerlink" title="游戏行业"></a>游戏行业</h2><p>账号登陆服务器、地图服务器之间可以方便的通过 Netty 进行高性能的通信。</p>
<h2 id="大数据领域"><a href="#大数据领域" class="headerlink" title="大数据领域"></a>大数据领域</h2><p>hadoop和序列化组件avro的rpc框架，都是采用netty作为底层通信组件</p>
<h1 id="以下是以Netty写的简单demo"><a href="#以下是以Netty写的简单demo" class="headerlink" title="以下是以Netty写的简单demo"></a><strong>以下是以Netty写的简单demo</strong></h1><p>服务端</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.netty.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.flogger.Flogger;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(); <span class="comment">//8</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            bootstrap.group(bossGroup, workerGroup) <span class="comment">//设置两个线程组</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.info(<span class="string">&quot;客户端channel 初始化&quot;</span>);</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">cf</span> <span class="operator">=</span> bootstrap.bind(<span class="number">9999</span>).sync();</span><br><span class="line">            log.info(<span class="string">&quot;服务启动成功....&quot;</span>);</span><br><span class="line">            cf.addListener((ChannelFutureListener) future -&gt; log.info(<span class="string">&quot;监听端口:&#123;&#125;&quot;</span>,future.isSuccess()));</span><br><span class="line">            cf.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">        log.info(<span class="string">&quot;收到客户端消息:&#123;&#125;&quot;</span>,byteBuf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        <span class="comment">// 现在通过通道给客户端回消息</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;客户端你好：我收到你的消息了&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>客户端</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.netty.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            <span class="comment">//设置相关参数</span></span><br><span class="line">            bootstrap.group(group)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyClientHandler</span>()); <span class="comment">//加入自己的处理器</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;客户端 ok..&quot;</span>);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9999</span>).sync();</span><br><span class="line">            <span class="comment">//给关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;服务端你好：我和你建立连接了&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">        log.info(<span class="string">&quot;收到服务端消息:&#123;&#125;&quot;</span>, byteBuf.toString(CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>Java</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>BIO|NIO|AIO的区别</title>
    <url>/2023/08/28/BIO-NIO-AIO%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[
  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>IO模型</p>

    </div>
    <div class="notel-content">
      <p><strong>IO模型</strong>指的是在网络数据传输过程中，使用什么通道去发送和接收数据，我们常见的有BIO、NIO、AIO(NIO2.0)</p>

    </div>
  </div>

<h2 id="同步-异步-阻塞-非阻塞-到底是什么意思？"><a href="#同步-异步-阻塞-非阻塞-到底是什么意思？" class="headerlink" title="同步&#x2F;异步&#x2F;阻塞&#x2F;非阻塞 到底是什么意思？"></a>同步&#x2F;异步&#x2F;阻塞&#x2F;非阻塞 到底是什么意思？</h2><ul>
<li><p><strong>同步&#x2F;异步</strong> 指的是你去调用一个方法，如果这个方法是同步的，那么你就会等待这个方法执行结束后才能执行后续操作；如果是异步的话，他会立即给你返回，但是这个不是真实的结果，真实的结果它是通过消息机制通知你或者回调机制通知你的。</p>
</li>
<li><p><strong>阻塞&#x2F;非阻塞</strong> 阻塞指的是当你去调用一个获取洗衣机信息方法的时候，如果这个时候没有洗衣机，那么方法就会一直阻塞，直到能查询到洗衣机的信息才会返回结果；非阻塞指的是当你调用一个获取洗衣机信息方法的时候，如果当时没有查到信息，你不会一直阻塞在那里，你这时可以去做别的事，但是你会时不时的去检查下是否有结果，然后再阻塞获取下，但是这不会影响你做其它事。</p>
</li>
</ul>
<div class="tabs" id="tab-lanmu1"><ul class="nav-tabs"><li class="tab active"><a class="#lanmu1-1">BIO(同步阻塞)</a></li><li class="tab"><a class="#lanmu1-2">NIO(同步非阻塞)</a></li><li class="tab"><a class="#lanmu1-3">AIO(异步非阻塞)</a></li></ul><div class="tab-content"><div class="tab-pane active" id="lanmu1-1"><p>我们经常使用的就是BIO，在我们学习编程基础javaSE的时候，应该都学过socket通信，这里面使用的就是同步阻塞。以下是BIO的模型：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/08/28/BIO-NIO-AIO%E7%9A%84%E5%8C%BA%E5%88%AB/640.webp"
                      class="" width="640"
                >

<p>在BIO模型中，一个连接会对应一个处理线程，如果服务端使用单线程进行处理，后续连接将会一直阻塞；</p>
<ul>
<li><p>缺点：</p>
<p>代码中的read,accept操作是阻塞操作，如果连接之后，服务端一直不发送数据，将会一直阻塞当前线程，浪费资源。</p>
<p>如果连接数很多，意味着创建的线程数量就会越来越多，会造成服务器压力太大，后续优化成线程池处理方式，勉强解决了此问题。</p>
</li>
<li><p>应用场景 BIO适用于连接数较少且固定的架构，这种模式对服务器资源要求较高，但程序复杂度比较低；</p>
</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">package</span> com.example.netty.bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">9000</span>);</span><br><span class="line">        socket.getOutputStream().write(<span class="string">&quot;我是客户端&quot;</span>.getBytes());</span><br><span class="line">        socket.getOutputStream().flush();</span><br><span class="line">        System.out.println(<span class="string">&quot;向服务端发送数据结束&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> socket.getInputStream().read(bytes);</span><br><span class="line">            System.out.println(<span class="string">&quot;服务端发送过来的数据为：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="number">0</span>,read));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//服务端</span></span><br><span class="line"> <span class="keyword">package</span> com.example.netty.bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketServer</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ServerSocket serverSocket=<span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9000</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;等待连接&quot;</span>);</span><br><span class="line">            <span class="comment">// 阻塞等待</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;有客户端连接了&quot;</span>);</span><br><span class="line">            handleRead(client);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> client</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleRead</span><span class="params">(Socket client)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> client.getInputStream().read(bytes);</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端发送过来的数据为：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="number">0</span>,read));</span><br><span class="line"><span class="comment">//                    Thread.sleep(Integer.MAX_VALUE);</span></span><br><span class="line">                    client.getOutputStream().write(<span class="string">&quot;你好，我收到你的数据了&quot;</span>.getBytes());</span><br><span class="line">                    client.getOutputStream().flush();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-pane" id="lanmu1-2"><p>NIO在BIO的基础上进行了升级，将阻塞换成非阻塞，虽然只是模式变了下，但是代码复杂量却增加了不少。在NIO模型中，服务端可以开启一个线程处理多个连接，它是非阻塞的，客户端发送的数据都会注册到多路复用器selector上面，当selector（selector的select方法是阻塞的）轮询到有读、写或者连接请求时，才会转发到后端程序进行处理，没有数据的时候，业务程序并不需要阻塞等待。</p>
<h3 id="NIO有三大组件：Channel-通道-、Buffer（缓存区）、Selector-选择器"><a href="#NIO有三大组件：Channel-通道-、Buffer（缓存区）、Selector-选择器" class="headerlink" title="NIO有三大组件：Channel(通道)、Buffer（缓存区）、Selector(选择器)"></a>NIO有三大组件：Channel(通道)、Buffer（缓存区）、Selector(选择器)</h3><ul>
<li>Channel 类似于流，但是它是一个双向的流，他是连接服务端和客户端的通道，不管是客户端还是服务端，都可以使用通道进行读写数据。</li>
<li>Buffer 它就是一个缓冲区，用来存放数据的载体，它借助通道，在客户端和服务端之间传递数据。</li>
<li>Selector 它对应一个或多个channel，客户端的连接都会注册到selector上面，然后由selector去调用后端处理程序</li>
</ul>
<h3 id="以下是NIO结构模型"><a href="#以下是NIO结构模型" class="headerlink" title="以下是NIO结构模型"></a>以下是NIO结构模型</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/08/28/BIO-NIO-AIO%E7%9A%84%E5%8C%BA%E5%88%AB/640-1732783216506-5.webp"
                      class="" title="640-1732783216506-5"
                ></h3><h3 id="NIO的非阻塞到底体现在哪里呢？"><a href="#NIO的非阻塞到底体现在哪里呢？" class="headerlink" title="NIO的非阻塞到底体现在哪里呢？"></a>NIO的非阻塞到底体现在哪里呢？</h3><p>​		从模型图可以看出，客户端所有的连接通道都会注册到selector上面，select会通过轮询去获取这些通道的状态，这些状态有accpet(连接请求)、READ读请求。</p>
<p>​		如果在轮询过程中发现已经有一个连接请求状态的话，这说明已经有一个客户端想要和服务端进行连接，直接把这个通道传给后端程序去处理连接操作；如果是在BIO模型下的话，会一直阻塞在accept上，直到有连接请求才会释放，继续执行后续的代码。</p>
<p>​		如果在轮询过程中发现已经有一个读请求状态的话，这说明已经有一个客户端把数据发送给服务端了，服务端可以直接把通道交给后端程序进行读操作的处理；如果是在BIO模型下的话，会一直阻塞在read上，直到有连接请求才会释放，继续执行后续的代码。</p>
<p><strong>「以上可以总结为：在NIO模型中，如果服务端执行了read操作的话，就说明已经有可用的数据进行读取了，如果执行了accpet操作的话，就说明此时一定有客户端发起了与服务端的连接，能够保证这种操作的前提是selector轮询到了可读可连接的通道状态。」</strong></p>
<h3 id="那如果selector轮询后，得到了多个通道的read和accpet状态，NIO是如何处理的？"><a href="#那如果selector轮询后，得到了多个通道的read和accpet状态，NIO是如何处理的？" class="headerlink" title="那如果selector轮询后，得到了多个通道的read和accpet状态，NIO是如何处理的？"></a>那如果selector轮询后，得到了多个通道的read和accpet状态，NIO是如何处理的？</h3><ul>
<li>单线程 如果在单线程模式下，处理方式是按照轮询后得到的变化的通道的先后顺序进行处理的，没错，它是同步进行处理的，也就是它只能处理完这个通道的操作，才能继续处理下个通道的请求，在selector代码中，是通过遍历所有有变化的通道进行处理的，后面大家看代码就明白了，这种一个selector对应一个线程的模式其实就是<strong>「redis的单线程IO模型」</strong>。</li>
<li>多线程 如果是在多线程模式下，selector在遍历每一个通道的时候，都会把对通道的操作交给一个线程去处理，一般都会丢到线程池中去处理，这个时候执行顺序就得看cpu的调度情况来决定了。</li>
</ul>
<p>接下来我们结合代码来整体看下NIO的工作机制</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.netty.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NioServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9000</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;等待事件发生&quot;</span>);</span><br><span class="line">            <span class="comment">// 这里还是阻塞等待，</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">select</span> <span class="operator">=</span> selector.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                handleChannel(selectionKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleChannel</span><span class="params">(SelectionKey selectionKey)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;有客户端发生了连接&quot;</span>);</span><br><span class="line">            <span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> channel.accept();</span><br><span class="line">                client.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                <span class="comment">// 连接之后立即注册读操作，客户端发送数据过来才能监听到</span></span><br><span class="line">                client.register(selectionKey.selector(), SelectionKey.OP_READ);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;收到客户端发送数据的请求&quot;</span>);</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) selectionKey.channel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果这里你不读取数据，读事件会一直触发，这是有NIO属于水平触发决定的，</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">allocate</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(allocate);</span><br><span class="line">                <span class="keyword">if</span> (read != -<span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端发送的数据:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(allocate.array(), <span class="number">0</span>, read));</span><br><span class="line">                &#125;</span><br><span class="line">                channel.write(ByteBuffer.wrap(<span class="string">&quot;你好，我是服务端&quot;</span>.getBytes()));</span><br><span class="line">                <span class="comment">// 处理完读操作之后，需要重新注册下读操作，</span></span><br><span class="line">                <span class="comment">// 如果下面一行被放开，将会一直会有可写操作触发，因为网络中99.999%的情况下都是可写的，一般不监听</span></span><br><span class="line"><span class="comment">//                selectionKey.interestOps(SelectionKey.OP_WRITE | SelectionKey.OP_READ);</span></span><br><span class="line">                selectionKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isWritable()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;触发写事件&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>服务端架构图</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/08/28/BIO-NIO-AIO%E7%9A%84%E5%8C%BA%E5%88%AB/640-1732784150171-8.webp"
                      class="" title="640-1732784150171-8"
                >

<ul>
<li>服务端代码说明<ol>
<li>创建一个 ServerSocketChannel 和 Selector ，并将 ServerSocketChannel 注册到 Selector 上</li>
<li>selector 通过 select() 方法监听 channel 事件，当客户端连接时，selector 监听到连接事件， 获取到 ServerSocketChannel 注册时 绑定的 selectionKey</li>
<li>selectionKey 通过 channel() 方法可以获取绑定的 ServerSocketChannel</li>
<li>ServerSocketChannel 通过 accept() 方法得到 SocketChannel</li>
<li>将 SocketChannel 注册到 Selector 上，关心 read 事件</li>
<li>注册后返回一个 SelectionKey, 会和该 SocketChannel 关联</li>
<li>selector 继续通过 select() 方法监听事件，当客户端发送数据给服务端，selector 监听到read事件，获取到 SocketChannel 注册时 绑定的 selectionKey</li>
<li>selectionKey 通过 channel() 方法可以获取绑定的 socketChannel</li>
<li>将 socketChannel 里的数据读取出来</li>
<li>用 socketChannel 将服务端数据写回客户端</li>
</ol>
</li>
</ul>
<p>这里注意一下在代码注释中提到的水平触发，我这做下解释：水平触发是多路复用中的一种模式，与此对应的还有一个边缘触发。</p>
<ul>
<li>水平触发 如果在通道中检测到数据变化后会触发通知，如果收到通知后，事件处理程序没有完全读取缓冲区中的所有数据或压根就没有读，那么在水平触发模式下，就会一直触发这个通知，直到缓冲区的内容被读取完，NIO中select和poll就属于这种模式</li>
<li>边缘触发 情况同上，不过是当系统通知一次之后，只有当通道中的数据再次发生改变后，才会再次发生通知。epoll既可以采用水平触发,也可以采用边缘触发</li>
</ul>
<p>客户端代码</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.netty.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NioClient</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">NioClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioClient</span>();</span><br><span class="line">        client.initClient(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9000</span>);</span><br><span class="line">        client.connect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 阻塞等待</span></span><br><span class="line">            selector.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                handler(selectionKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handler</span><span class="params">(SelectionKey selectionKey)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 收到服务端发送的数据</span></span><br><span class="line">        <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) selectionKey.channel();</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (len != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端收到信息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, len));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 连接事件发生</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isConnectable()) &#123;</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) selectionKey.channel();</span><br><span class="line">            <span class="comment">// 一般发起了连接后，会立即返回，需要使用isConnectionPending判断是否完成连接，如果正在连接，则调用finishConnect，如果不能连接则会抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (channel.isConnectionPending()) &#123;</span><br><span class="line">                channel.finishConnect();</span><br><span class="line">            &#125;</span><br><span class="line">            channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="string">&quot;你好，我是客户端&quot;</span>.getBytes());</span><br><span class="line">            channel.write(buffer);</span><br><span class="line">            selectionKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initClient</span><span class="params">(String s, <span class="type">int</span> i)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(s, i));</span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="多路复用常见的底层实现api"><a href="#多路复用常见的底层实现api" class="headerlink" title="多路复用常见的底层实现api"></a>多路复用常见的底层实现api</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/08/28/BIO-NIO-AIO%E7%9A%84%E5%8C%BA%E5%88%AB/640-1732784307236-11.webp"
                      class="" title="640-1732784307236-11"
                >

<p>poll相比selelct，没有最大连接的限制；epoll相对于前两者，是一个不一样的机制，基于事件通知的方式，通知调用者；</p></div><div class="tab-pane" id="lanmu1-3"><p>异步非阻塞， 由操作系统完成后回调通知服务端程序启动线程去处理， 一般适用于连接数较多且连接时间较长的应用 应用场景：AIO方式适用于连接数目多且连接比较长（重操作） 的架构，JDK7 开始支持</p>
<ul>
<li>AIO代码示例：</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务端代码</span></span><br><span class="line">    <span class="keyword">package</span> com.example.netty.aio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AioServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">AsynchronousServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span></span><br><span class="line">                AsynchronousServerSocketChannel.open().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9000</span>));</span><br><span class="line">        serverChannel.accept(<span class="literal">null</span>,<span class="keyword">new</span>  <span class="title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Object&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(AsynchronousSocketChannel socketChannel, Object attachment)</span> &#123;</span><br><span class="line">                serverChannel.accept(attachment, <span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(socketChannel.getRemoteAddress());</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    socketChannel.read(buffer, buffer, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, result));</span><br><span class="line">                            socketChannel.write(ByteBuffer.wrap(<span class="string">&quot;HelloAioClient&quot;</span>.getBytes()));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, Object attachment)</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">package</span> com.example.netty.aio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AioClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException, IOException &#123;</span><br><span class="line">        <span class="type">AsynchronousSocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> AsynchronousSocketChannel.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9000</span>)).get();</span><br><span class="line">        socketChannel.write(ByteBuffer.wrap(<span class="string">&quot;HelloServer&quot;</span>.getBytes()));</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">len</span> <span class="operator">=</span> socketChannel.read(buffer).get();</span><br><span class="line">        <span class="keyword">if</span> (len!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端收到信息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div></div>

<p>「总结：可以看出异步非阻塞模式的代码是非常简单的，所有的操作都是通过回调机制触发的，我们只需要在回调方法中处理我们自己的逻辑就行了，其实AIO是基于NIO进行封装，后面会讲到的netty也是基于NIO进行封装的」</p>
<h2 id="BIO、NIO、AIO区别"><a href="#BIO、NIO、AIO区别" class="headerlink" title="BIO、NIO、AIO区别"></a>BIO、NIO、AIO区别</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/08/28/BIO-NIO-AIO%E7%9A%84%E5%8C%BA%E5%88%AB/640-1732784411947-14.webp"
                      class="" title="640-1732784411947-14"
                >
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>Java</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty(二)Netty的组件</title>
    <url>/2023/08/29/Netty(%E4%BA%8C)Netty%E7%9A%84%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="Netty组件"><a href="#Netty组件" class="headerlink" title="Netty组件"></a>Netty组件</h1><h2 id="ServerBootstrap-Bootstrap"><a href="#ServerBootstrap-Bootstrap" class="headerlink" title="ServerBootstrap&#x2F;Bootstrap"></a>ServerBootstrap&#x2F;Bootstrap</h2><p>这两个属于引导类加载器，它们分别是服务端启动配置引导类和客户端启动配置引导类。通过这个引导类 串联netty所有的组件</p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>Netty 网络通信的组件，能够用于执行网络 I&#x2F;O 操作。Channel 为用户提供：</p>
<p>1）当前网络连接的通道的状态（例如是否打开？是否已连接？）</p>
<p>2）网络连接的配置参数 （例如接收缓冲区大小）</p>
<p>3）提供异步的网络 I&#x2F;O 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 I&#x2F;O 调用都将立即返回，并且不保证在调用结束时所请求的 I&#x2F;O 操作已完成。</p>
<p>4）调用立即返回一个 ChannelFuture 实例，通过注册监听器到 ChannelFuture 上，在 I&#x2F;O 操作成功、失败时会通过回调的方式通知调用方。我们现在已经见到的有SocketChannel 和ServerSocketChannel,后面还会见到更多。</p>
<h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>netty 是基于selector对象 实现多路复用。关于多路复用实现方式，我们在第一节课也给大家介绍了，这里就不展开讲了。netty通过selector 单个线程就可以实现对多个客户端channel事件的监听。</p>
<h2 id="NioEventLoop"><a href="#NioEventLoop" class="headerlink" title="NioEventLoop"></a>NioEventLoop</h2><p>NioEventLoop内部维护了一个线程和一个任务队列，支持异步提交任务。线程启动后会调用loop的run方法，执行异步队列中的非I&#x2F;O任务和I&#x2F;O任务。</p>
<h3 id="IO任务"><a href="#IO任务" class="headerlink" title="IO任务"></a>IO任务</h3><p>accecpt、connect、read、write</p>
<h3 id="非I-O任务"><a href="#非I-O任务" class="headerlink" title="非I&#x2F;O任务"></a>非I&#x2F;O任务</h3><p>注册、绑定等</p>
<h2 id="NioEventLoopGroup"><a href="#NioEventLoopGroup" class="headerlink" title="NioEventLoopGroup"></a>NioEventLoopGroup</h2><p>内部维护多个NioEventLoop，负责处理多个channel事件，但是一个channel只会交给一个NioEventLoop处理</p>
<h2 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h2><p>ChannelHandler 处在pipline中，它有两种类型：进站和出站，当服务端收到消息时，所有的进站hanlder将会被执行，当服务端往客户端写消息时，所有的出站handler将会被执行。</p>
<p>针对I&#x2F;O的数据处理器数据接收后，通过指定的Handler进行处理</p>
<h2 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a>ChannelHandlerContext</h2><p>用来保存ChannelHandler的上下文信息</p>
<h2 id="ChannelPipline"><a href="#ChannelPipline" class="headerlink" title="ChannelPipline"></a>ChannelPipline</h2><p>这就是上面说的pipline，一个pipline中会维护很多handler，保存一个handler list ，这里涉及到一个设计模式：职责链设计模式。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/Netty-%E4%BA%8C-Netty%E7%9A%84%E7%BB%84%E4%BB%B6/640.webp"
                      alt="图片"
                ></p>
<h1 id="Netty工作流程图"><a href="#Netty工作流程图" class="headerlink" title="Netty工作流程图"></a>Netty工作流程图</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/Netty-%E4%BA%8C-Netty%E7%9A%84%E7%BB%84%E4%BB%B6/image-20241130170535631.png"
                      alt="image-20241130170535631"
                ></p>
<h1 id="为什么有了ByteBuffer，Netty还弄一套ByteBuf？"><a href="#为什么有了ByteBuffer，Netty还弄一套ByteBuf？" class="headerlink" title="为什么有了ByteBuffer，Netty还弄一套ByteBuf？"></a>为什么有了ByteBuffer，Netty还弄一套ByteBuf？</h1><p>当然是在某些场景下，jdk自带的ByteBuffer 性能不是很令netty满意，而且使用比较复杂，所以netty团队重新设计了ByteBuf重新替代ByteBuffer</p>
<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><h2 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a>ByteBuffer</h2><h3 id="读模式"><a href="#读模式" class="headerlink" title="读模式"></a>读模式</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/Netty-%E4%BA%8C-Netty%E7%9A%84%E7%BB%84%E4%BB%B6/640.webp"
                      alt="图片"
                ></p>
<h3 id="写模式"><a href="#写模式" class="headerlink" title="写模式"></a>写模式</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/Netty-%E4%BA%8C-Netty%E7%9A%84%E7%BB%84%E4%BB%B6/640-1732891053489-1.webp"
                      alt="图片"
                ></p>
<p>在读模式下，从头开始读取数据，一直读到limit位置就代表数据读取完成，capacity代表容量。</p>
<p>在写模式下，position移到数据终点位置（也就是之前读模式下的limit位置），然后limit移到capacity位置。此时数据从position位置开始写，一直到limit(capacity)位置，停止写入。</p>
<h2 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h2><p>主要通过两个index:readindex和writeindex来完成数据的读写，整个缓冲区分为三个部分：可丢弃部分、可读部分、可写部分。</p>
<h3 id="初始位置"><a href="#初始位置" class="headerlink" title="初始位置"></a>初始位置</h3><p>当缓冲区为空的时候，writeindex和readindex都为0，整个区域都为可写部分</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/Netty-%E4%BA%8C-Netty%E7%9A%84%E7%BB%84%E4%BB%B6/640-1732891053490-2.webp"
                      alt="图片"
                ></p>
<h3 id="写了一点数据后"><a href="#写了一点数据后" class="headerlink" title="写了一点数据后"></a>写了一点数据后</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/Netty-%E4%BA%8C-Netty%E7%9A%84%E7%BB%84%E4%BB%B6/640-1732891053491-3.webp"
                      alt="图片"
                ></p>
<h3 id="读了一点数据后"><a href="#读了一点数据后" class="headerlink" title="读了一点数据后"></a>读了一点数据后</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/Netty-%E4%BA%8C-Netty%E7%9A%84%E7%BB%84%E4%BB%B6/640-1732891053491-4.webp"
                      alt="图片"
                ></p>
<h3 id="丢弃部分被清理后"><a href="#丢弃部分被清理后" class="headerlink" title="丢弃部分被清理后"></a>丢弃部分被清理后</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/Netty-%E4%BA%8C-Netty%E7%9A%84%E7%BB%84%E4%BB%B6/640-1732891053492-5.webp"
                      alt="图片"
                ></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>Java</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32(二)GPIO</title>
    <url>/2023/09/24/STM32(%E4%BA%8C)GPIO/</url>
    <content><![CDATA[<h1 id="GPIO介绍"><a href="#GPIO介绍" class="headerlink" title="GPIO介绍"></a>GPIO介绍</h1><p><strong>GPIO（General Purpose Input Output）通用输入输出口</strong></p>
<ul>
<li>可配置为8种输入输出模式</li>
<li>引脚电平：0V~3.3V，部分引脚可容忍5V</li>
<li>输出模式下可控制端口输出高低电平，用以驱动LED、控制蜂鸣器、模拟通信协议输出时序等</li>
<li>输入模式下可读取端口的高低电平或电压，用于读取按键输入、外接模块电平信号输入、ADC电压采集、模拟通信协议接收数据等</li>
</ul>
<h1 id="GPIO基本结构"><a href="#GPIO基本结构" class="headerlink" title="GPIO基本结构"></a>GPIO基本结构</h1><p>寄存器上一节有讲过，用于<strong>存储和操作数据</strong></p>
<p>驱动器是用来<strong>增加信号的驱动能力</strong>的，如果要进行点灯这样的操作，就需要驱动器来负责增大驱动能力</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/STM32-%E4%BA%8C-GPIO/image-20250220004237221.png"
                      alt="image-20250220004237221"
                ></p>
<h1 id="GPIO位结构"><a href="#GPIO位结构" class="headerlink" title="GPIO位结构"></a>GPIO位结构</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/STM32-%E4%BA%8C-GPIO/image-20250220010948159.png"
                      alt="image-20250220010948159"
                ></p>
<h2 id="Vdd和Vss"><a href="#Vdd和Vss" class="headerlink" title="Vdd和Vss"></a>Vdd和Vss</h2><p>在STM32微控制器中，Vdd 和 Vss 是芯片的电源引脚，用于为芯片供电。例如：</p>
<ul>
<li><strong>Vdd</strong>：连接到 3.3V 电源。</li>
<li><strong>Vss</strong>：连接到地，0V（GND）</li>
</ul>
<h2 id="保护二极管"><a href="#保护二极管" class="headerlink" title="保护二极管"></a>保护二极管</h2><p>保护二极管：<strong>保护内部电路</strong>。当输入电压在0~3.3V之间，两个保护二极管均不会导通，这时二极管对电路没有影响</p>
<p><strong>大于3.3V</strong>，上方的保护二极管会被导通，电流会从I&#x2F;O引脚流向Vdd</p>
<p><strong>小于0V</strong>（负电压），下方的保护二极管会被导通，电流会从Vss流向I&#x2F;O引脚（电流会从<strong>高电压流向低电压</strong>，即从0–&gt;-5）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/STM32-%E4%BA%8C-GPIO/image-20250220011914846.png"
                      alt="image-20250220011914846"
                ></p>
<h2 id="上拉-下拉输入模式"><a href="#上拉-下拉输入模式" class="headerlink" title="上拉&#x2F;下拉输入模式"></a>上拉&#x2F;下拉输入模式</h2><blockquote>
<p><strong>上面导通</strong>，下面断开，就是<strong>上拉输入模式</strong></p>
<p><strong>下面导通</strong>，上面断开，就是<strong>下拉输入模式</strong></p>
<p>两个<strong>都断开</strong>，就是<strong>浮空输入模式</strong></p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/STM32-%E4%BA%8C-GPIO/image-20250220012523523.png"
                      alt="image-20250220012523523"
                ></p>
<h3 id="上拉和下拉的作用"><a href="#上拉和下拉的作用" class="headerlink" title="上拉和下拉的作用"></a>上拉和下拉的作用</h3><p><strong>作用</strong>：为了给输入提供一个默认的输入电平的</p>
<p>因为对应一个数字的端口，输入不是高电平就是低电平</p>
<p>那如果输入引脚啥都不接，到底是算高电平还是还是低电平呢？</p>
<blockquote>
<p>这就不好说了，对于实际情况，如果输入什么都不接，这时输入就会处于一种<strong>浮空状态</strong>（即不稳定的状态）</p>
<p>这时引脚的输入电平就极易受外界干扰而改变，受到一点扰动就会变化</p>
<p><strong>为了避免引脚悬空（浮空）导致的输入数据不确定</strong>，<strong>我们就需要在这里加上 上拉或者下拉电阻</strong></p>
<ul>
<li><p>如果接入上拉电阻，当引脚悬空时，还有上拉电阻来保证引脚的高电平，</p>
<p>所以上拉输入可以默认为高电平的输入模式</p>
</li>
<li><p>如果接入下拉电阻，当引脚悬空时，还有下拉电阻来保证引脚的低电平，</p>
<p>所以下拉输入可以默认为低电平的输入模式</p>
</li>
</ul>
</blockquote>
<p><strong>注意：</strong>这个上拉电阻和下拉电阻的阻值都是比较大的，是一种弱上拉和弱下拉，<strong>目的是尽量不影响正常的输入操作</strong></p>
<h2 id="施密特触发器"><a href="#施密特触发器" class="headerlink" title="施密特触发器"></a>施密特触发器</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/STM32-%E4%BA%8C-GPIO/image-20250220145720533.png"
                      alt="image-20250220145720533"
                ></p>
<p>*<strong>这里应该是施密特触发器，只是画错了</strong></p>
<p>作用：对输入电压进行整形</p>
<p>执行逻辑：如果输入电压<strong>大于</strong>某一阈值，输出就会瞬间升为高电平</p>
<p>​				   如果输入电压<strong>小于</strong>某一阈值，输出就会瞬间升为低电平</p>
<p>举例：因为这个引脚的波形是外界输入的，虽然是数字信号，实际情况下可能会产生各种失真</p>
<blockquote>
<p>这里用了两个<strong>比较阈值</strong>（绿线）来进行判断，中间留有一定的变化范围，这样可以有效避免因信号波动造成的输出抖动现象，经过施密特触发器整形的波形就可以直接写入<strong>输入数据寄存器</strong>了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/STM32-%E4%BA%8C-GPIO/image-20250220155155148.png"
                      alt="image-20250220155155148"
                ></p>
</blockquote>
<h2 id="输入数据寄存器"><a href="#输入数据寄存器" class="headerlink" title="输入数据寄存器"></a>输入数据寄存器</h2><p>通过程序就能读取输入数据寄存器中的某一位数据，就可以知道端口的输入电平了</p>
<h2 id="片上外设"><a href="#片上外设" class="headerlink" title="片上外设"></a>片上外设</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/STM32-%E4%BA%8C-GPIO/image-20250220161732886.png"
                      alt="image-20250220161732886"
                ></p>
<ul>
<li><strong>模拟输入</strong> 连接到ADC上的，因为ADC需要<strong>接收模拟量</strong>，所以这根线是<strong>接到施密特触发器前</strong></li>
<li><strong>复用功能输入</strong> 这个是连接到其他需要读取端口的外设上的 ，比如串口的输入引脚等，这根线接收的是<strong>数字量</strong>，所以这根线是<strong>接到施密特触发器后</strong></li>
</ul>
<h2 id="位设置-位清除寄存器"><a href="#位设置-位清除寄存器" class="headerlink" title="位设置&#x2F;位清除寄存器"></a>位设置&#x2F;位清除寄存器</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/STM32-%E4%BA%8C-GPIO/image-20250220162910089.png"
                      alt="image-20250220162910089"
                ></p>
<p>位置1：</p>
<p>如果我们要对某一位进行置1的操作，在<strong>位设置寄存器</strong>的对应位写1即可，剩下不需要操作的位写0。</p>
<p>这样它内部就会有电路，自动将输出数据奇存器中对应位置为1，而剩下写0的位则保持不变。</p>
<p>这样就保证了只操作其中某一位而不影响其它位，并且这是一步到位的操作</p>
<p>清0：</p>
<p>如果想对某一位进行清0的操作，就在<strong>位清除寄存器</strong>的对应位写1即可，这样内部电路就会把这一位清0了</p>
<h2 id="MOS管"><a href="#MOS管" class="headerlink" title="MOS管"></a>MOS管</h2><p>MOS管就是一种电子开关</p>
<p>我们的信号来控制开关的导通和关闭，开关负责将IO口接到VDD或者VSS</p>
<p>在这里可以选择<strong>推挽、开漏或关闭</strong>三种输出方式</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/STM32-%E4%BA%8C-GPIO/image-20250220163202677.png"
                      alt="image-20250220163202677"
                ></p>
<h1 id="GPIO的八种工作模式"><a href="#GPIO的八种工作模式" class="headerlink" title="GPIO的八种工作模式"></a>GPIO的八种工作模式</h1><p>通过配置GPIO的端口配置寄存器 ，端口可以配置成以下8种模式</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/STM32-%E4%BA%8C-GPIO/image-20250220171704985.png"
                      alt="image-20250220171704985"
                ></p>
<h2 id="浮空-上拉-下拉输入"><a href="#浮空-上拉-下拉输入" class="headerlink" title="浮空&#x2F;上拉&#x2F;下拉输入"></a>浮空&#x2F;上拉&#x2F;下拉输入</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/STM32-%E4%BA%8C-GPIO/image-20250220173316357.png"
                      alt="image-20250220173316357"
                ></p>
<h2 id="模拟输入"><a href="#模拟输入" class="headerlink" title="模拟输入"></a>模拟输入</h2><p>当我们使用ADC的时候，将引脚配置为模拟输入就行了，其他时候，一般用不到模拟输入</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/STM32-%E4%BA%8C-GPIO/image-20250220173337171.png"
                      alt="image-20250220173337171"
                ></p>
<h2 id="开漏输出和推挽输出"><a href="#开漏输出和推挽输出" class="headerlink" title="开漏输出和推挽输出"></a>开漏输出和推挽输出</h2><p>输出是由输出数据寄存器控制的</p>
<blockquote>
<ol>
<li>如果P-MOS无效、N-MOS有效，就是<strong>开漏输出</strong></li>
<li>如果P-MOS和N-MOS都有效，就是<strong>推挽输出</strong></li>
<li>另外，在输出模式下，输入模式也是有效的（也就是配置成输出模式，既可以输出，也可以输入）</li>
</ol>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/STM32-%E4%BA%8C-GPIO/image-20250220173828386.png"
                      alt="image-20250220173828386"
                ></p>
<h2 id="复用开漏-推挽输出"><a href="#复用开漏-推挽输出" class="headerlink" title="复用开漏&#x2F;推挽输出"></a>复用开漏&#x2F;推挽输出</h2><p>复用输出时，引脚的控制权转移到了片上外设，<strong>由片上外设来控制</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/STM32-%E4%BA%8C-GPIO/image-20250220173949426.png"
                      alt="image-20250220173949426"
                ></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>其实在GPIO的这8种模式中，除了<strong>模拟输入</strong>这个模式<strong>会关闭数字的输入功能</strong>，在其他的7个模式中，所有的输入都是有效的</li>
</ul>
<h1 id="LED和蜂鸣器"><a href="#LED和蜂鸣器" class="headerlink" title="LED和蜂鸣器"></a>LED和蜂鸣器</h1><ul>
<li>LED：发光二极管，正向通电点亮，反向通电不亮</li>
<li>有源蜂鸣器：内部自带振荡源，将正负极接上直流电压即可持续发声，频率固定</li>
<li>无源蜂鸣器：内部不带振荡源，需要控制器提供振荡脉冲才可发声，调整提供振荡脉冲的频率，可发出不同频率的声音</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/STM32-%E4%BA%8C-GPIO/image-20250220175918205.png"
                      alt="image-20250220175918205"
                ></p>
<h2 id="如何接"><a href="#如何接" class="headerlink" title="如何接"></a>如何接</h2><p>GPIO在推挽输出模式下，高低电平均有比较强的驱动能力，所以在这里，这两种接法均可</p>
<p>但是在单片机的电路里，一般倾向使用<strong>第一种接法</strong></p>
<p>因为很多单片机或者芯片，都使用了<strong>高电平弱驱动</strong>，<strong>低电平强驱动</strong>的规则，这样可以一定程度上<strong>避免高低电平打架</strong></p>
<p>所以如果高电平驱动能力弱，那就不能使用第二种连接方法了（开漏输出模式下，高电平没有驱动能力，不适用）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/STM32-%E4%BA%8C-GPIO/image-20250220175925353.png"
                      alt="image-20250220175925353"
                ></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>GPIO</tag>
      </tags>
  </entry>
  <entry>
    <title>Swagger2</title>
    <url>/2023/09/20/Swagger2/</url>
    <content><![CDATA[<p>现如今，前后端分离已经逐渐成为互联网项目一种标准的开发方式，前端与后端交给不同的人员开发，</p>
<p>但是项目开发中的沟通成本也随之升高，这部分沟通成本主要在于前端开发人员与后端开发人员对WebAPI接口的沟通，Swagger2 就可以很好地解决，它可以动态生成Api接口文档，降低沟通成本，促进项目高效开发。</p>
<p>有时候定义了文档，代码中修改了一点小的东西，总会忘记同步修改文档，时间长了，自己都比较蒙，还需要看一下代码才能发现问题。</p>
<h1 id="Swagger介绍"><a href="#Swagger介绍" class="headerlink" title="Swagger介绍"></a>Swagger介绍</h1><p>Spring Boot 可以集成Swagger，生成Swagger接口，Spring Boot是Java领域的神器，它是Spring项目下快速构建<br>项目的框架</p>
<h1 id="集成Swagger2"><a href="#集成Swagger2" class="headerlink" title="集成Swagger2"></a>集成Swagger2</h1><div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencys</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--swagger2--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencys</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h1 id="Swagger的基础注解介绍"><a href="#Swagger的基础注解介绍" class="headerlink" title="Swagger的基础注解介绍"></a>Swagger的基础注解介绍</h1><p>swagger通过注解生成接口文档，包括接口名、请求方法、参数、返回信息的等等。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Api：修饰整个类，描述Controller的作用</span><br><span class="line">@ApiOperation：描述一个类的一个方法，或者说一个接口</span><br><span class="line">@ApiParam：单个参数描述</span><br><span class="line">@ApiModel：用对象实体来作为入参</span><br><span class="line">@ApiProperty：用对象接实体收参数时，描述对象的一个字段</span><br><span class="line">@ApiResponse：HTTP响应其中1个描述</span><br><span class="line">@ApiResponses：HTTP响应整体描述</span><br><span class="line">@ApiIgnore：使用该注解忽略这个API</span><br><span class="line">@ApiError ：发生错误返回的信息</span><br><span class="line">@ApiImplicitParam：一个请求参数</span><br><span class="line">@ApiImplicitParams： 多个请求参数</span><br></pre></td></tr></table></figure></div>

<h3 id="Api"><a href="#Api" class="headerlink" title="@Api"></a>@Api</h3><p>修饰整个类，描述Controller的作用</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/swagger&quot;)</span></span><br><span class="line"><span class="meta">@Api(value = &quot;swagger2的demo例子&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerController</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="ApiOperation"><a href="#ApiOperation" class="headerlink" title="@ApiOperation"></a>@ApiOperation</h3><p>用于描述一个方法或者接口</p>
<p>可以添加的参数形式：@ApiOperation(value &#x3D; “接口说明”, httpMethod &#x3D; “接口请求方式”, response &#x3D; “接口返回参数类型”, notes &#x3D; “接口发布说明”）</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/swagger&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@ApiOperation(value = &quot;根据用户名获取用户的信息&quot;,notes = &quot;查询数据库中的记录&quot;,httpMethod = &quot;POST&quot;,response = String.class)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserInfo</span><span class="params">(String userName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="ApiImplicitParam-一个请求参数"><a href="#ApiImplicitParam-一个请求参数" class="headerlink" title="@ApiImplicitParam 一个请求参数"></a>@ApiImplicitParam 一个请求参数</h3><p>一个请求参数，@ApiImplicitParam(required &#x3D; “是否必须参数”, name &#x3D; “参数名称”, value &#x3D; “参数具体描述”,dateType&#x3D;“变量类型”,paramType&#x3D;”请求方式”）</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiImplicitParam(name = &quot;userName&quot;,value = &quot;用户名&quot;,required = true,dataType = &quot;String&quot;,paramType = &quot;query&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserInfo</span><span class="params">(String userName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="ApiImplicitParams-多个请求参数"><a href="#ApiImplicitParams-多个请求参数" class="headerlink" title="@ApiImplicitParams 多个请求参数"></a>@ApiImplicitParams 多个请求参数</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiImplicitParams(&#123;</span></span><br><span class="line"><span class="meta">    @ApiImplicitParam(name = &quot;nickName&quot;,value = &quot;用户的昵称&quot;,paramType = &quot;query&quot;,dataType = &quot;String&quot;,required = true),</span></span><br><span class="line"><span class="meta">    @ApiImplicitParam(name = &quot;id&quot;,value = &quot;用户的ID&quot;,paramType = &quot;query&quot;,dataType = &quot;Integer&quot;,required = true)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUserInfoByNickName</span><span class="params">(String nickName, Integer id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="UI界面"><a href="#UI界面" class="headerlink" title="UI界面"></a>UI界面</h1><p>运行程序 ：<code>http://localhost:8080/swagger-ui.html</code></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/20/Swagger2/image-20250120221858691.png"
                      class="" title="image-20250120221858691"
                >
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Swagger2</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32(一)介绍</title>
    <url>/2023/09/23/STM32-%E4%B8%80-%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="STM32介绍"><a href="#STM32介绍" class="headerlink" title="STM32介绍"></a>STM32介绍</h1><ul>
<li>STM32是ST公司基于ARM Cortex-M内核开发的32位微控制器</li>
<li>STM32常应用在嵌入式领域，如智能车、无人机、机器人、无线通信、物联网、工业控制、娱乐电子产品等</li>
<li>STM32功能强大、性能优异、片上资源丰富、功耗低，是一款经典的嵌入式微控制器</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/23/STM32-%E4%B8%80-%E4%BB%8B%E7%BB%8D/image-20250219155220550.png"
                      class="" title="image-20250219155220550"
                >

<h1 id="ARM"><a href="#ARM" class="headerlink" title="ARM"></a>ARM</h1><ul>
<li>ARM既指ARM公司，也指ARM处理器内核</li>
<li>ARM公司是全球领先的半导体知识产权（IP）提供商，全世界超过95%的智能手机和平板电脑都采用ARM架构</li>
<li>ARM公司设计ARM内核，半导体厂商完善内核周边电路并生产芯片</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/23/STM32-%E4%B8%80-%E4%BB%8B%E7%BB%8D/image-20250219155416036.png"
                      class="" title="image-20250219155416036"
                >

<h1 id="STM32F103C8T6"><a href="#STM32F103C8T6" class="headerlink" title="STM32F103C8T6"></a>STM32F103C8T6</h1><ul>
<li>系列：主流系列STM32F1</li>
<li>内核：ARM Cortex-M3</li>
<li>主频：72MHz</li>
<li>RAM：20K（SRAM）</li>
<li>ROM：64K（Flash）</li>
<li>供电：2.0~3.6V（标准3.3V）</li>
<li>封装：LQFP48</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/23/STM32-%E4%B8%80-%E4%BB%8B%E7%BB%8D/image-20250219161707997.png"
                      class="" title="image-20250219161707997"
                >

<h2 id="片上资源-外设"><a href="#片上资源-外设" class="headerlink" title="片上资源&#x2F;外设"></a>片上资源&#x2F;外设</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/23/STM32-%E4%B8%80-%E4%BB%8B%E7%BB%8D/image-20250219161745905.png"
                      class="" title="image-20250219161745905"
                >

<h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/23/STM32-%E4%B8%80-%E4%BB%8B%E7%BB%8D/image-20250219161805093.png"
                      class="" title="image-20250219161805093"
                >

<h2 id="系统结构"><a href="#系统结构" class="headerlink" title="系统结构"></a>系统结构</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/23/STM32-%E4%B8%80-%E4%BB%8B%E7%BB%8D/image-20250219161820738.png"
                      class="" title="image-20250219161820738"
                >

<h2 id="引脚定义"><a href="#引脚定义" class="headerlink" title="引脚定义"></a>引脚定义</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/23/STM32-%E4%B8%80-%E4%BB%8B%E7%BB%8D/image-20250219161934607.png"
                      class="" title="image-20250219161934607"
                >

<h2 id="启动配置"><a href="#启动配置" class="headerlink" title="启动配置"></a>启动配置</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/23/STM32-%E4%B8%80-%E4%BB%8B%E7%BB%8D/image-20250219162016931.png"
                      class="" title="image-20250219162016931"
                >

<h2 id="最小系统电路"><a href="#最小系统电路" class="headerlink" title="最小系统电路"></a>最小系统电路</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/23/STM32-%E4%B8%80-%E4%BB%8B%E7%BB%8D/image-20250219162038399.png"
                      class="" title="image-20250219162038399"
                >

<h1 id="术语介绍"><a href="#术语介绍" class="headerlink" title="术语介绍"></a>术语介绍</h1><h2 id="使能"><a href="#使能" class="headerlink" title="使能"></a>使能</h2><p><strong>使能</strong>（Enable）在嵌入式系统和电子工程中是一个常见的术语，意思是<strong>激活某个功能或模块</strong>，使其进入工作状态。在STM32微控制器中，使能通常指的是通过配置寄存器或调用库函数来激活某个外设或功能。</p>
<hr>
<h3 id="1-使能的具体含义"><a href="#1-使能的具体含义" class="headerlink" title="1. 使能的具体含义"></a>1. <strong>使能的具体含义</strong></h3><ul>
<li><strong>使能某个外设</strong>：激活该外设的时钟信号，使其可以正常工作。</li>
<li><strong>使能某个功能</strong>：激活某个特定的功能模块，例如中断、DMA传输等。</li>
</ul>
<hr>
<h3 id="2-为什么需要使能？"><a href="#2-为什么需要使能？" class="headerlink" title="2. 为什么需要使能？"></a>2. <strong>为什么需要使能？</strong></h3><p>在STM32中，许多外设和功能模块默认是关闭的（为了节省功耗），因此在使用之前需要手动使能。例如：</p>
<ul>
<li><strong>外设时钟</strong>：每个外设（如GPIO、USART、SPI等）都需要时钟信号才能工作。默认情况下，外设的时钟是关闭的，必须通过配置RCC（复位和时钟控制）寄存器来使能。</li>
<li><strong>中断</strong>：中断功能默认是关闭的，需要使能后才能响应外部事件。</li>
<li><strong>DMA</strong>：DMA传输功能默认是关闭的，需要使能后才能使用。</li>
</ul>
<h2 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h2><p>STM32的所有外设（包括GPIO、USART、SPI等）都需要<strong>时钟信号</strong>才能正常工作，<strong>时钟信号是外设运行的基础</strong>。</p>
<h3 id="1-为什么需要时钟？"><a href="#1-为什么需要时钟？" class="headerlink" title="1. 为什么需要时钟？"></a>1. <strong>为什么需要时钟？</strong></h3><ul>
<li>时钟信号是微控制器内部和外设运行的“心跳”，它决定了<strong>外设的工作频率</strong>。（<strong>时钟信号</strong> 是数字电路中的一种周期性信号，用于同步各部件操作，确保数据在正确时间传输和处理。）</li>
<li><strong>每个外设</strong>（包括GPIOC）<strong>都需要</strong>时钟信号来<strong>驱动</strong>其<strong>内部逻辑电路</strong>。</li>
<li><strong>默认情况下，STM32的外设时钟是关闭的（为了节能）</strong>，因此在<strong>使用某个外设（如GPIOC）之前</strong>，必须<strong>使能</strong>其时钟。</li>
</ul>
<hr>
<h3 id="2-GPIOC时钟的来源"><a href="#2-GPIOC时钟的来源" class="headerlink" title="2. GPIOC时钟的来源"></a>2. <strong>GPIOC时钟的来源</strong></h3><p>在STM32中，GPIOC的时钟来源于<strong>AHB总线</strong>（高级高性能总线），通过<strong>APB2外设时钟使能寄存器（RCC_APB2ENR）</strong>控制。</p>
<ul>
<li><strong>AHB总线</strong>：高速总线，为许多外设提供时钟。</li>
<li><strong>APB2总线</strong>：AHB总线的子集，负责为高速外设（如GPIO、USART1、SPI1等）提供时钟。</li>
</ul>
<hr>
<h3 id="3-如何使能GPIOC的时钟？"><a href="#3-如何使能GPIOC的时钟？" class="headerlink" title="3. 如何使能GPIOC的时钟？"></a>3. <strong>如何使能GPIOC的时钟？</strong></h3><p>在STM32的标准外设库（Standard Peripheral Library）或HAL库中，可以通过以下代码使能GPIOC的时钟：</p>
<h4 id="使用标准外设库"><a href="#使用标准外设库" class="headerlink" title="使用标准外设库"></a>使用标准外设库</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>  <span class="comment">// 根据具体的STM32型号包含对应的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 使能GPIOC的时钟</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他代码</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 主循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="使用HAL库"><a href="#使用HAL库" class="headerlink" title="使用HAL库"></a>使用HAL库</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f1xx_hal.h&quot;</span>  <span class="comment">// 根据具体的STM32型号包含对应的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    HAL_Init();  <span class="comment">// 初始化HAL库</span></span><br><span class="line">    SystemClock_Config();  <span class="comment">// 配置系统时钟</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使能GPIOC的时钟</span></span><br><span class="line">    __HAL_RCC_GPIOC_CLK_ENABLE();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他代码</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 主循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="4-时钟使能的底层原理"><a href="#4-时钟使能的底层原理" class="headerlink" title="4. 时钟使能的底层原理"></a>4. <strong>时钟使能的底层原理</strong></h3><p>在STM32中，时钟使能是通过配置<strong>RCC（复位和时钟控制）寄存器</strong>实现的。对于GPIOC，具体的寄存器是<code>RCC_APB2ENR</code>。</p>
<ul>
<li><strong>RCC_APB2ENR寄存器</strong>：控制APB2总线上外设的时钟使能。</li>
<li><strong>GPIOC的时钟使能位</strong>：在<code>RCC_APB2ENR</code>寄存器中，GPIOC的时钟使能位是第4位（<code>IOPCEN</code>）。</li>
</ul>
<p>例如，使能GPIOC时钟的底层操作如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPCEN;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="5-时钟使能的重要性"><a href="#5-时钟使能的重要性" class="headerlink" title="5. 时钟使能的重要性"></a>5. <strong>时钟使能的重要性</strong></h3><ul>
<li><strong>如果没有使能GPIOC的时钟，GPIOC的所有操作（如设置引脚模式、读写引脚状态等）都将无效。</strong></li>
<li>使能时钟后，GPIOC的寄存器才能被正确访问和配置。</li>
</ul>
<hr>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. <strong>总结</strong></h3><ul>
<li><strong>GPIOC的时钟</strong>是为GPIOC外设提供工作频率的信号。</li>
<li>在使用GPIOC之前，必须通过RCC寄存器或库函数使能其时钟。</li>
<li>时钟使能是STM32外设配置的第一步，是外设正常工作的前提。</li>
</ul>
<p>如果你使用的是具体的STM32型号（如STM32F1、STM32F4等），可以参考对应型号的参考手册（Reference Manual）和数据手册（Datasheet），了解更详细的时钟树结构和寄存器配置。</p>
<h2 id="外设"><a href="#外设" class="headerlink" title="外设"></a>外设</h2><p>在STM32微控制器中，<strong>外设</strong>（Peripheral）是指<strong>集成在芯片内部</strong>、<strong>用于实现特定功能的硬件模块</strong>。</p>
<p>STM32微控制器不仅仅是一个CPU，它还集成了许多外设，用于处理各种任务。如GPIO（通用输入输出）、USART（串口通信）、SPI（串行外设接口）、I2C（集成电路总线）、定时器、ADC（模数转换器）等。</p>
<hr>
<h3 id="1-外设的作用"><a href="#1-外设的作用" class="headerlink" title="1. 外设的作用"></a>1. <strong>外设的作用</strong></h3><p>外设是STM32与外部世界交互的桥梁。它们可以：</p>
<ul>
<li>控制硬件（如点亮LED、驱动电机）。</li>
<li>采集数据（如读取传感器信号）。</li>
<li>通信（如通过串口、SPI、I2C与其他设备通信）。</li>
<li>计时和计数（如定时器、PWM输出）。</li>
</ul>
<hr>
<h3 id="2-常见的外设"><a href="#2-常见的外设" class="headerlink" title="2. 常见的外设"></a>2. <strong>常见的外设</strong></h3><p>以下是一些STM32中常见的外设：</p>
<h4 id="1-GPIO（通用输入输出）"><a href="#1-GPIO（通用输入输出）" class="headerlink" title="(1) GPIO（通用输入输出）"></a>(1) <strong>GPIO（通用输入输出）</strong></h4><ul>
<li>用于控制引脚的电平（高电平或低电平）。</li>
<li>可以配置为输入模式（读取外部信号）或输出模式（驱动外部设备）。</li>
<li>例如：点亮LED、读取按键状态。</li>
</ul>
<h4 id="2-USART-UART（串口通信）"><a href="#2-USART-UART（串口通信）" class="headerlink" title="(2) USART&#x2F;UART（串口通信）"></a>(2) <strong>USART&#x2F;UART（串口通信）</strong></h4><ul>
<li>用于串行通信，支持异步传输。</li>
<li>常用于与PC、传感器、蓝牙模块等设备通信。</li>
</ul>
<h4 id="3-SPI（串行外设接口）"><a href="#3-SPI（串行外设接口）" class="headerlink" title="(3) SPI（串行外设接口）"></a>(3) <strong>SPI（串行外设接口）</strong></h4><ul>
<li>高速全双工通信接口。</li>
<li>常用于与Flash存储器、显示屏、传感器等设备通信。</li>
</ul>
<h4 id="4-I2C（集成电路总线）"><a href="#4-I2C（集成电路总线）" class="headerlink" title="(4) I2C（集成电路总线）"></a>(4) <strong>I2C（集成电路总线）</strong></h4><ul>
<li>双线制通信接口，支持多设备连接。</li>
<li>常用于与EEPROM、温度传感器等设备通信。</li>
</ul>
<h4 id="5-定时器（TIM）"><a href="#5-定时器（TIM）" class="headerlink" title="(5) 定时器（TIM）"></a>(5) <strong>定时器（TIM）</strong></h4><ul>
<li>用于计时、生成PWM信号、捕获输入信号等。</li>
<li>例如：控制电机的转速、测量脉冲宽度。</li>
</ul>
<h4 id="6-ADC（模数转换器）"><a href="#6-ADC（模数转换器）" class="headerlink" title="(6) ADC（模数转换器）"></a>(6) <strong>ADC（模数转换器）</strong></h4><ul>
<li>将模拟信号（如电压）转换为数字信号。</li>
<li>例如：读取电位器的电压、采集传感器数据。</li>
</ul>
<h4 id="7-DAC（数模转换器）"><a href="#7-DAC（数模转换器）" class="headerlink" title="(7) DAC（数模转换器）"></a>(7) <strong>DAC（数模转换器）</strong></h4><ul>
<li>将数字信号转换为模拟信号。</li>
<li>例如：生成音频信号、控制模拟电压输出。</li>
</ul>
<h4 id="8-DMA（直接存储器访问）"><a href="#8-DMA（直接存储器访问）" class="headerlink" title="(8) DMA（直接存储器访问）"></a>(8) <strong>DMA（直接存储器访问）</strong></h4><ul>
<li>用于在内存和外设之间直接传输数据，无需CPU干预。</li>
<li>例如：高速数据传输、减少CPU负载。</li>
</ul>
<h4 id="9-CAN（控制器局域网）"><a href="#9-CAN（控制器局域网）" class="headerlink" title="(9) CAN（控制器局域网）"></a>(9) <strong>CAN（控制器局域网）</strong></h4><ul>
<li>用于工业通信，支持多设备组网。</li>
<li>例如：汽车电子、工业控制。</li>
</ul>
<h4 id="10-USB（通用串行总线）"><a href="#10-USB（通用串行总线）" class="headerlink" title="(10) USB（通用串行总线）"></a>(10) <strong>USB（通用串行总线）</strong></h4><ul>
<li>用于与PC或其他USB设备通信。</li>
<li>例如：USB键盘、USB存储设备。</li>
</ul>
<hr>
<h3 id="3-外设与CPU的关系"><a href="#3-外设与CPU的关系" class="headerlink" title="3. 外设与CPU的关系"></a>3. <strong>外设与CPU的关系</strong></h3><ul>
<li><strong>CPU</strong>：负责执行程序代码，控制外设的运行。</li>
<li><strong>外设</strong>：负责具体的硬件操作，减轻CPU的负担。</li>
<li><strong>总线</strong>：CPU通过总线（如AHB、APB）与外设通信，访问外设的寄存器。</li>
</ul>
<hr>
<h3 id="4-外设的时钟"><a href="#4-外设的时钟" class="headerlink" title="4. 外设的时钟"></a>4. <strong>外设的时钟</strong></h3><p>每个外设都需要时钟信号才能工作。STM32的时钟系统非常复杂，外设的时钟来源可以是：</p>
<ul>
<li><strong>系统时钟（SYSCLK）</strong>：主时钟源，通常由外部晶振或内部振荡器提供。</li>
<li><strong>AHB总线时钟</strong>：高速总线时钟，为许多外设提供时钟。</li>
<li><strong>APB1&#x2F;APB2总线时钟</strong>：低速总线时钟，为特定外设提供时钟。</li>
</ul>
<p>在使用某个外设之前，必须使能其时钟。例如：</p>
<ul>
<li>使用GPIO时，需要使能GPIO的时钟。</li>
<li>使用USART时，需要使能USART的时钟。</li>
</ul>
<hr>
<h3 id="5-外设的寄存器"><a href="#5-外设的寄存器" class="headerlink" title="5. 外设的寄存器"></a>5. <strong>外设的寄存器</strong></h3><p>每个外设都有一组寄存器，用于配置和控制其行为。例如：</p>
<ul>
<li><strong>GPIO的寄存器</strong>：配置引脚模式、读取引脚状态。</li>
<li><strong>USART的寄存器</strong>：设置波特率、发送和接收数据。</li>
<li><strong>定时器的寄存器</strong>：设置计数值、启动或停止定时器。</li>
</ul>
<p>通过读写这些寄存器，可以控制外设的工作方式。</p>
<hr>
<h3 id="6-总结-1"><a href="#6-总结-1" class="headerlink" title="6. 总结"></a>6. <strong>总结</strong></h3><ul>
<li><strong>外设</strong>是STM32微控制器内部的硬件模块，用于实现特定功能。</li>
<li>外设通过与CPU协作，完成各种任务（如通信、数据采集、控制硬件等）。</li>
<li>每个外设都需要时钟信号才能工作，且需要通过寄存器进行配置。</li>
</ul>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p><strong>寄存器</strong>（Register）是计算机和微控制器中一种非常重要的硬件组件，<strong>用于存储和操作数据</strong>。在STM32微控制器中，寄存器是CPU与外设之间交互的桥梁，通过读写寄存器可以配置外设的行为、获取外设的状态或传输数据。</p>
<h3 id="1-寄存器的基本概念"><a href="#1-寄存器的基本概念" class="headerlink" title="1. 寄存器的基本概念"></a>1. <strong>寄存器的基本概念</strong></h3><ul>
<li><strong>寄存器</strong>是一种高速的存储单元，位于CPU或外设内部。</li>
<li>每个寄存器通常由多个<strong>位（bit）</strong>组成，每个位可以存储一个二进制值（0或1）。</li>
<li>寄存器的位数取决于具体的硬件设计，例如STM32中的寄存器通常是32位的。</li>
</ul>
<hr>
<h3 id="2-寄存器的作用"><a href="#2-寄存器的作用" class="headerlink" title="2. 寄存器的作用"></a>2. <strong>寄存器的作用</strong></h3><p>在STM32中，寄存器的主要作用包括：</p>
<ul>
<li><strong>配置外设</strong>：通过写寄存器设置外设的工作模式、参数等。</li>
<li><strong>控制外设</strong>：通过写寄存器启动或停止外设的工作。</li>
<li><strong>获取状态</strong>：通过读寄存器获取外设的当前状态。</li>
<li><strong>传输数据</strong>：通过寄存器在CPU和外设之间传输数据。</li>
</ul>
<hr>
<h3 id="3-寄存器的分类"><a href="#3-寄存器的分类" class="headerlink" title="3. 寄存器的分类"></a>3. <strong>寄存器的分类</strong></h3><p>在STM32中，寄存器可以分为以下几类：</p>
<h4 id="1-CPU寄存器"><a href="#1-CPU寄存器" class="headerlink" title="(1) CPU寄存器"></a>(1) <strong>CPU寄存器</strong></h4><ul>
<li>位于CPU内部，用于执行指令和临时存储数据。</li>
<li>例如：程序计数器（PC）、堆栈指针（SP）、通用寄存器（R0-R12）等。</li>
</ul>
<h4 id="2-外设寄存器"><a href="#2-外设寄存器" class="headerlink" title="(2) 外设寄存器"></a>(2) <strong>外设寄存器</strong></h4><ul>
<li>位于外设内部，用于配置和控制外设的行为。</li>
<li>例如：<ul>
<li><strong>GPIO寄存器</strong>：配置引脚模式、读写引脚状态。</li>
<li><strong>USART寄存器</strong>：设置波特率、发送和接收数据。</li>
<li><strong>定时器寄存器</strong>：设置计数值、启动或停止定时器。</li>
</ul>
</li>
</ul>
<h4 id="3-特殊功能寄存器"><a href="#3-特殊功能寄存器" class="headerlink" title="(3) 特殊功能寄存器"></a>(3) <strong>特殊功能寄存器</strong></h4><ul>
<li>用于控制系统级别的功能。</li>
<li>例如：<ul>
<li><strong>RCC寄存器</strong>：配置系统时钟和外设时钟。</li>
<li><strong>NVIC寄存器</strong>：配置中断优先级和使能中断。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-寄存器的访问"><a href="#4-寄存器的访问" class="headerlink" title="4. 寄存器的访问"></a>4. <strong>寄存器的访问</strong></h3><p>在STM32中，寄存器是通过内存映射的方式访问的。每个寄存器都有一个唯一的地址，可以通过指针或库函数来读写寄存器。</p>
<h4 id="1-直接访问寄存器"><a href="#1-直接访问寄存器" class="headerlink" title="(1) 直接访问寄存器"></a>(1) <strong>直接访问寄存器</strong></h4><p>通过指针访问寄存器的地址。例如：</p>
<ul>
<li><p>读取GPIOC的输入数据寄存器：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint32_t input_data = GPIOC-&gt;IDR;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>设置GPIOC的引脚为高电平：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GPIOC-&gt;ODR |= (1 &lt;&lt; 5);  // 设置第5位为1</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="2-使用库函数访问寄存器"><a href="#2-使用库函数访问寄存器" class="headerlink" title="(2) 使用库函数访问寄存器"></a>(2) <strong>使用库函数访问寄存器</strong></h4><p>STM32提供了标准外设库和HAL库，封装了寄存器的操作。例如：</p>
<ul>
<li><p>使用标准外设库设置GPIO引脚：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GPIO_SetBits(GPIOC, GPIO_Pin_5);  // 设置GPIOC的第5引脚为高电平</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>使用HAL库配置USART：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">HAL_USART_Init(&amp;husart1);</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. <strong>总结</strong></h3><ul>
<li><strong>寄存器</strong>是微控制器中用于存储和操作数据的硬件单元。</li>
<li>通过读写寄存器，可以配置外设、控制外设、获取状态和传输数据。</li>
<li>寄存器通常通过内存映射的方式访问，每个寄存器都有唯一的地址。</li>
<li>在STM32中，寄存器是开发的基础，理解寄存器的使用是掌握STM32编程的关键。</li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>欢迎来到我的博客</title>
    <url>/2023/08/26/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[
  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>自我介绍</p>

    </div>
    <div class="notel-content">
      <p>本人是一个技术上的小菜鸡，该博客只为记录自己的学习历程。</p>
<p>若发现笔记里面存在不对的地方，欢迎大家留言讨论。</p>
<p>最后，希望能和大家共同进步~</p>

    </div>
  </div>
]]></content>
  </entry>
  <entry>
    <title>规则引擎Drools</title>
    <url>/2023/09/13/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8EDrools/</url>
    <content><![CDATA[<h2 id="1-规则引擎概述"><a href="#1-规则引擎概述" class="headerlink" title="1 规则引擎概述"></a>1 规则引擎概述</h2><ul>
<li>规则引擎核心思想：将应用程序中的业务决策部分分离出来</li>
<li>使得业务规则的变更不需要修改项目代码、重启服务器就可以在线上环境立即生效</li>
</ul>
<h2 id="2-Drools入门案例"><a href="#2-Drools入门案例" class="headerlink" title="2 Drools入门案例"></a>2 Drools入门案例</h2><h3 id="第一步-创建SpringBoot工程"><a href="#第一步-创建SpringBoot工程" class="headerlink" title="第一步 创建SpringBoot工程"></a>第一步 创建SpringBoot工程</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/13/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8EDrools/image-20240529202037057.png"
                      class="" title="image-20240529202037057"
                >



<h3 id="第二步-引入Drools相关依赖"><a href="#第二步-引入Drools相关依赖" class="headerlink" title="第二步 引入Drools相关依赖"></a>第二步 引入Drools相关依赖</h3><div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>17<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">drools.version</span>&gt;</span>8.41.0.Final<span class="tag">&lt;/<span class="name">drools.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;drools.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-compiler<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;drools.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-decisiontables<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;drools.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-mvel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;drools.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></div>



<h3 id="第三步-创建Drools配置类"><a href="#第三步-创建Drools配置类" class="headerlink" title="第三步 创建Drools配置类"></a>第三步 创建Drools配置类</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 规则引擎配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DroolsConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">KieServices</span> <span class="variable">kieServices</span> <span class="operator">=</span> KieServices.Factory.get();</span><br><span class="line">    <span class="comment">//制定规则文件的路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RULES_CUSTOMER_RULES_DRL</span> <span class="operator">=</span> <span class="string">&quot;rules/order.drl&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> KieContainer <span class="title function_">kieContainer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//获得Kie容器对象</span></span><br><span class="line">        <span class="type">KieFileSystem</span> <span class="variable">kieFileSystem</span> <span class="operator">=</span> kieServices.newKieFileSystem();</span><br><span class="line">        kieFileSystem.write(ResourceFactory.newClassPathResource(RULES_CUSTOMER_RULES_DRL));</span><br><span class="line"></span><br><span class="line">        <span class="type">KieBuilder</span> <span class="variable">kieBuilder</span> <span class="operator">=</span> kieServices.newKieBuilder(kieFileSystem);</span><br><span class="line">        kieBuilder.buildAll();</span><br><span class="line"></span><br><span class="line">        <span class="type">KieModule</span> <span class="variable">kieModule</span> <span class="operator">=</span> kieBuilder.getKieModule();</span><br><span class="line">        <span class="type">KieContainer</span> <span class="variable">kieContainer</span> <span class="operator">=</span> kieServices.newKieContainer(kieModule.getReleaseId());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> kieContainer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="第四步-创建实体类"><a href="#第四步-创建实体类" class="headerlink" title="第四步 创建实体类"></a>第四步 创建实体类</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> amout;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getAmout</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> amout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAmout</span><span class="params">(<span class="type">double</span> amout)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.amout = amout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">double</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="第五步-创建规则文件"><a href="#第五步-创建规则文件" class="headerlink" title="第五步 创建规则文件"></a>第五步 创建规则文件</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//订单积分规则</span></span><br><span class="line"><span class="keyword">package</span> com.asjm.drools.order</span><br><span class="line"><span class="keyword">import</span> com.asjm.drools.bean.Order</span><br><span class="line"></span><br><span class="line"><span class="comment">//规则一：100元以下 不加分</span></span><br><span class="line">rule <span class="string">&quot;order_rule_1&quot;</span></span><br><span class="line">    when</span><br><span class="line">        $order:Order(amout &lt; <span class="number">100</span>)</span><br><span class="line">    then</span><br><span class="line">        $order.setScore(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;成功匹配到规则一：100元以下 不加分&quot;</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment">//规则二：100元 - 500元 加100分</span></span><br><span class="line">rule <span class="string">&quot;order_rule_2&quot;</span></span><br><span class="line">    when</span><br><span class="line">        $order:Order(amout &gt;= <span class="number">100</span> &amp;&amp; amout &lt; <span class="number">500</span>)</span><br><span class="line">    then</span><br><span class="line">         $order.setScore(<span class="number">100</span>);</span><br><span class="line">         System.out.println(<span class="string">&quot;成功匹配到规则二：100元 - 500元 加100分&quot;</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment">//规则三：500元 - 1000元 加500分</span></span><br><span class="line">rule <span class="string">&quot;order_rule_3&quot;</span></span><br><span class="line">    when</span><br><span class="line">        $order:Order(amout &gt;= <span class="number">500</span> &amp;&amp; amout &lt; <span class="number">1000</span>)</span><br><span class="line">    then</span><br><span class="line">         $order.setScore(<span class="number">500</span>);</span><br><span class="line">         System.out.println(<span class="string">&quot;成功匹配到规则三：500元 - 1000元 加500分&quot;</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment">//规则四：1000元以上 加1000分</span></span><br><span class="line">rule <span class="string">&quot;order_rule_4&quot;</span></span><br><span class="line">    when</span><br><span class="line">        $order:Order(amout &gt;= <span class="number">1000</span>)</span><br><span class="line">    then</span><br><span class="line">         $order.setScore(<span class="number">1000</span>);</span><br><span class="line">         System.out.println(<span class="string">&quot;成功匹配到规则四：1000元以上 加1000分&quot;</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure></div>



<h3 id="第六步-测试"><a href="#第六步-测试" class="headerlink" title="第六步 测试"></a>第六步 测试</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DroolsDemosApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KieContainer kieContainer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//从Kie容器对象中获取会话对象</span></span><br><span class="line">        <span class="type">KieSession</span> <span class="variable">session</span> <span class="operator">=</span> kieContainer.newKieSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Fact对象，事实对象</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        order.setAmout(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将Order对象插入到工作内存中</span></span><br><span class="line">        session.insert(order);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//激活规则，由Drools框架自动进行规则匹配，如果规则匹配成功，则执行当前规则</span></span><br><span class="line">        session.fireAllRules();</span><br><span class="line">        <span class="comment">//关闭会话</span></span><br><span class="line">        session.dispose();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;订单金额：&quot;</span> + order.getAmout() +</span><br><span class="line">                <span class="string">&quot;，添加积分：&quot;</span> + order.getScore());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="3-规则引擎组成和执行流程"><a href="#3-规则引擎组成和执行流程" class="headerlink" title="3 规则引擎组成和执行流程"></a>3 规则引擎组成和执行流程</h2><p>drools规则引擎由以下三部分构成：</p>
<ul>
<li>Working Memory（工作内存）</li>
<li>Rule Base（规则库）</li>
<li>Inference Engine（推理引擎）</li>
</ul>
<p>其中Inference Engine（推理引擎）又包括：</p>
<ul>
<li>Pattern Matcher（匹配器）     具体匹配哪一个规则，由这个完成</li>
<li>Agenda(议程)</li>
<li>Execution Engine（执行引擎）</li>
</ul>
<h2 id="3-Drools基础语法"><a href="#3-Drools基础语法" class="headerlink" title="3 Drools基础语法"></a>3 Drools基础语法</h2><h3 id="3-1-规则文件组成"><a href="#3-1-规则文件组成" class="headerlink" title="3.1 规则文件组成"></a>3.1 规则文件组成</h3><ul>
<li>在使用Drools时非常重要的一个工作就是编写规则文件，通常规则文件的后缀为.drl</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/13/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8EDrools/image-20240529204819712.png"
                      class="" title="image-20240529204819712"
                >

<h3 id="3-2-规则体语法结构"><a href="#3-2-规则体语法结构" class="headerlink" title="3.2 规则体语法结构"></a>3.2 规则体语法结构</h3><ul>
<li><p>规则体语法结构 开始位置 rule，结束位置 end</p>
</li>
<li><p>结构组成：</p>
</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">rule <span class="string">&quot;ruleName&quot;</span></span><br><span class="line">    attributes</span><br><span class="line">    when</span><br><span class="line">        LHS </span><br><span class="line">    then</span><br><span class="line">        RHS</span><br><span class="line">end</span><br></pre></td></tr></table></figure></div>

<p><strong>rule</strong>：关键字，表示规则开始，参数为规则的唯一名称。</p>
<p><strong>attributes</strong>：规则属性，是rule与when之间的参数，为可选项。</p>
<p><strong>when</strong>：关键字，后面跟规则的条件部分。</p>
<p><strong>LHS</strong>(Left Hand Side)：是规则的条件部分的通用名称。它由零个或多个条件元素组成。<strong>如果LHS为空，则它将被视为始终为true的条件元素</strong>。  （左手边）</p>
<p><strong>then</strong>：关键字，后面跟规则的结果部分。</p>
<p><strong>RHS</strong>(Right Hand Side)：是规则的后果或行动部分的通用名称。 （右手边）</p>
<p><strong>end</strong>：关键字，表示一个规则结束。</p>
<h3 id="3-3-模式匹配"><a href="#3-3-模式匹配" class="headerlink" title="3.3 模式匹配"></a>3.3 模式匹配</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">rule <span class="string">&quot;rule_1&quot;</span></span><br><span class="line">	when</span><br><span class="line">		$order:Order(amout &gt;<span class="number">100</span> &amp;&amp; amout &lt; <span class="number">500</span>)</span><br><span class="line">	then</span><br><span class="line">		$order.setScore(<span class="number">100</span>);</span><br><span class="line">		 System.out.println(<span class="string">&quot;成功匹配到规则二：100元 - 500元 加100分&quot;</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure></div>



<h3 id="3-4-Drools内置方法"><a href="#3-4-Drools内置方法" class="headerlink" title="3.4 Drools内置方法"></a>3.4 Drools内置方法</h3><ul>
<li><p>Drools提供了一些方法可以用来操作工作内存中的数据，<strong>操作完成后规则引擎会重新进行相关规则的匹配，</strong>原来没有匹配成功的规则在我们修改数据完成后有可能就会匹配成功了。</p>
</li>
<li><p><strong>修改 update方法</strong></p>
</li>
</ul>
<p><strong>update方法的作用是更新工作内存中的数据，并让相关的规则重新匹配。</strong></p>
<p>参数：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Fact对象，事实对象</span></span><br><span class="line"><span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">order.setAmout(<span class="number">30</span>);</span><br></pre></td></tr></table></figure></div>

<p>规则：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">rule <span class="string">&quot;order_rule_1&quot;</span></span><br><span class="line">	when</span><br><span class="line">		$order:Order(amout &lt; <span class="number">100</span>)</span><br><span class="line">	then</span><br><span class="line">		$order.setAmout(<span class="number">150</span>);</span><br><span class="line">		update($order)</span><br><span class="line">		System.out.println(<span class="string">&quot;成功匹配到规则一：100元以下 不加分&quot;</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">&quot;order_rule_2&quot;</span></span><br><span class="line">	when</span><br><span class="line">		$order:Order(amout &gt;= <span class="number">100</span> &amp;&amp; amout &lt; <span class="number">500</span>)</span><br><span class="line">	then</span><br><span class="line">		$order.setScore(<span class="number">100</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;成功匹配到规则二：100元 - 500元 加100分&quot;</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure></div>



<ul>
<li><strong>添加 insert方法</strong></li>
</ul>
<p><strong>insert方法的作用是向工作内存中插入数据，并让相关的规则重新匹配</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">rule <span class="string">&quot;order_rule_1&quot;</span></span><br><span class="line">	when</span><br><span class="line">		$order:Order(amout &lt; <span class="number">100</span>)</span><br><span class="line">	then</span><br><span class="line">		<span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">		order.setAmout(<span class="number">150</span>);</span><br><span class="line">		insert(order);</span><br><span class="line">		System.out.println(<span class="string">&quot;成功匹配到规则一：100元以下 不加分&quot;</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">&quot;order_rule_2&quot;</span></span><br><span class="line">	when</span><br><span class="line">		$order:Order(amout &gt;= <span class="number">100</span> &amp;&amp; amout &lt; <span class="number">500</span>)</span><br><span class="line">	then</span><br><span class="line">		$order.setScore(<span class="number">100</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;成功匹配到规则二：100元 - 500元 加100分&quot;</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure></div>



<ul>
<li><strong>删除 retract方法</strong></li>
</ul>
<p><strong>retract方法的作用是删除工作内存中的数据，并让相关的规则重新匹配。</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//规则一：100元以下 不加分</span></span><br><span class="line">rule <span class="string">&quot;order_rule_1&quot;</span></span><br><span class="line">    when</span><br><span class="line">        $order:Order(amout &lt; <span class="number">100</span>)</span><br><span class="line">    then</span><br><span class="line">        <span class="title function_">retract</span><span class="params">($order)</span>      <span class="comment">//retract方法的作用是删除工作内存中的Fact对象，会导致相关规则重新匹配</span></span><br><span class="line">        System.out.println(<span class="string">&quot;成功匹配到规则一：100元以下 不加分&quot;</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure></div>



<h2 id="4-Drools规则属性"><a href="#4-Drools规则属性" class="headerlink" title="4 Drools规则属性"></a>4 Drools规则属性</h2><h3 id="4-1-salience属性"><a href="#4-1-salience属性" class="headerlink" title="4.1 salience属性"></a>4.1 salience属性</h3><ul>
<li>salience属性用于指定规则的执行优先级，<strong>取值类型为Integer</strong>。<strong>数值越大越优先执行</strong></li>
<li>没有添加执行优先级，执行由上到下执行</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.order</span><br><span class="line"></span><br><span class="line">rule <span class="string">&quot;rule_1&quot;</span></span><br><span class="line">    when</span><br><span class="line">        <span class="title function_">eval</span><span class="params">(<span class="literal">true</span>)</span></span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">&quot;规则rule_1触发&quot;</span>);</span><br><span class="line">end</span><br><span class="line">    </span><br><span class="line">rule <span class="string">&quot;rule_2&quot;</span></span><br><span class="line">    when</span><br><span class="line">        <span class="title function_">eval</span><span class="params">(<span class="literal">true</span>)</span></span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">&quot;规则rule_2触发&quot;</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">&quot;rule_3&quot;</span></span><br><span class="line">    when</span><br><span class="line">        <span class="title function_">eval</span><span class="params">(<span class="literal">true</span>)</span></span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">&quot;规则rule_3触发&quot;</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure></div>



<ul>
<li>添加优先级</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.order</span><br><span class="line"></span><br><span class="line">rule <span class="string">&quot;rule_1&quot;</span></span><br><span class="line">    salience <span class="number">9</span></span><br><span class="line">    when</span><br><span class="line">        <span class="title function_">eval</span><span class="params">(<span class="literal">true</span>)</span></span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">&quot;规则rule_1触发&quot;</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">&quot;rule_2&quot;</span></span><br><span class="line">    salience <span class="number">10</span></span><br><span class="line">    when</span><br><span class="line">        <span class="title function_">eval</span><span class="params">(<span class="literal">true</span>)</span></span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">&quot;规则rule_2触发&quot;</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">rule <span class="string">&quot;rule_3&quot;</span></span><br><span class="line">    salience <span class="number">8</span></span><br><span class="line">    when</span><br><span class="line">        <span class="title function_">eval</span><span class="params">(<span class="literal">true</span>)</span></span><br><span class="line">    then</span><br><span class="line">        System.out.println(<span class="string">&quot;规则rule_3触发&quot;</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure></div>



<h3 id="4-2-no-loop属性"><a href="#4-2-no-loop属性" class="headerlink" title="4.2 no-loop属性"></a>4.2 no-loop属性</h3><ul>
<li><strong>no-loop属性用于防止死循环</strong></li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//订单积分规则</span></span><br><span class="line"><span class="keyword">package</span> com.order</span><br><span class="line"><span class="keyword">import</span> com.asjm.drools.model.Order</span><br><span class="line"></span><br><span class="line"><span class="comment">//规则一：100元以下 不加分</span></span><br><span class="line">rule <span class="string">&quot;order_rule_1&quot;</span></span><br><span class="line">    no-loop <span class="literal">true</span>         <span class="comment">//防止陷入死循环</span></span><br><span class="line">    when</span><br><span class="line">        $order:Order(amout &lt; <span class="number">100</span>)</span><br><span class="line">    then</span><br><span class="line">        $order.setScore(<span class="number">0</span>);</span><br><span class="line">        update($order)</span><br><span class="line">        System.out.println(<span class="string">&quot;成功匹配到规则一：100元以下 不加分&quot;</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure></div>



<h2 id="5-Drools高级语法"><a href="#5-Drools高级语法" class="headerlink" title="5 Drools高级语法"></a>5 Drools高级语法</h2><ul>
<li><p>global关键字用于在规则文件中<strong>定义全局变量</strong>，它可以让应用程序的对象在规则文件中能够被访问。</p>
</li>
<li><p>语法结构为：<strong>global 对象类型 对象名称</strong></p>
</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//订单积分规则</span></span><br><span class="line"><span class="keyword">package</span> com.order</span><br><span class="line"><span class="keyword">import</span> com.asjm.drools.bean.Order1</span><br><span class="line"></span><br><span class="line">global com.asjm.drools.bean.Integral integral;</span><br><span class="line"></span><br><span class="line"><span class="comment">//规则一：100元以下 不加分</span></span><br><span class="line">rule <span class="string">&quot;order_rule_1&quot;</span></span><br><span class="line">    no-loop <span class="literal">true</span>         <span class="comment">//防止陷入死循环</span></span><br><span class="line">    when</span><br><span class="line">        $order:Order1(amout &lt; <span class="number">100</span>)</span><br><span class="line">    then</span><br><span class="line">        integral.setScore(<span class="number">10</span>);</span><br><span class="line">        update($order)</span><br><span class="line">        System.out.println(<span class="string">&quot;成功匹配到规则一：100元以下 不加分&quot;</span>);</span><br><span class="line">end</span><br></pre></td></tr></table></figure></div>



<p>测试</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DroolsDemosApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KieContainer kieContainer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//从Kie容器对象中获取会话对象</span></span><br><span class="line">        <span class="type">KieSession</span> <span class="variable">session</span> <span class="operator">=</span> kieContainer.newKieSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Fact对象，事实对象</span></span><br><span class="line">        <span class="type">Order1</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order1</span>();</span><br><span class="line">        order.setAmout(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//全局变量</span></span><br><span class="line">        <span class="type">Integral</span> <span class="variable">integral</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integral</span>();</span><br><span class="line">        session.setGlobal(<span class="string">&quot;integral&quot;</span>,integral);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将Order对象插入到工作内存中</span></span><br><span class="line">        session.insert(order);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//激活规则，由Drools框架自动进行规则匹配，如果规则匹配成功，则执行当前规则</span></span><br><span class="line">        session.fireAllRules();</span><br><span class="line">        <span class="comment">//关闭会话</span></span><br><span class="line">        session.dispose();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;订单金额：&quot;</span> + order.getAmout() +</span><br><span class="line">                <span class="string">&quot;，添加积分：&quot;</span> + integral.getScore());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>中间件</tag>
        <tag>Drools</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学</title>
    <url>/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/</url>
    <content><![CDATA[<p><strong>密码学在网络安全、信息安全和区块链等产品中都扮演者重要的角色，常见的非对称加密、对称加密、散列函数等，都属于密码学范例</strong></p>
<h1 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h1><p>散列函数，也见杂凑函数、摘要函数或哈希函数，可将任意长度的消息经过运算，变成<strong>固定长度数值</strong>，常见的有<code>MD5</code>、<code>SHA-1</code>、<code>SHA256</code>，多应用在<strong>文件校验</strong>，<strong>数字签名</strong>中。</p>
<p><strong>MD5</strong> 可以将任意长度的原文生成一个  <em><strong>128位（16字节）</strong></em>   的哈希值</p>
<p><strong>SHA-1</strong>可以将任意长度的原文生成一个 <em><strong>160位（20字节）</strong></em>  的哈希值</p>
<h1 id="对称密码"><a href="#对称密码" class="headerlink" title="对称密码"></a>对称密码</h1><p>对称密码应用了相同的加密密钥和解密密钥。对称密码分为：序列密码(流密码)，分组密码(块密码)两种。流密码是对信息流中的每一个元素（一个字母或一个比特）作为基本的处理单元进行加密，块密码是先对信息流分块，再对每一块分别加密。</p>
<blockquote>
<p>例如原文为1234567890</p>
<p><strong>流加密</strong>先对1进行加密，再对2进行加密，再对3进行加密……最后拼接成密文</p>
<p><strong>块加密</strong>先分成不同的块，如1234成块，5678成块，90XX(XX为补位数字)成块，再分别对不同块进行加密，最后拼接成密文</p>
</blockquote>
<h1 id="非对称密码"><a href="#非对称密码" class="headerlink" title="非对称密码"></a>非对称密码</h1><p>对称密码的密钥安全极其重要，<strong>加密者和解密者需要提前协商密钥</strong>，并各自确保密钥的安全性，一但密钥泄露，即使算法是安全的也无法保障原文信息的私密性。</p>
<p>而<strong>在实际的使用中</strong>，<strong>远程的提前协商密钥不容易实现</strong>，即使协商好，在远程传输过程中也容易被他人获取，因此非对称密钥此时就凸显出了优势。</p>
<blockquote>
<ul>
<li><p>非对称密码有两支密钥，<strong>公钥（publickey）</strong>和<strong>私钥（privatekey）</strong>，加密和解密运算使用的密钥不同。</p>
</li>
<li><p>用公钥对原文进行加密后，需要由私钥进行解密</p>
</li>
<li><p>用私钥对原文进行加密后（此时一般称为<strong>签名</strong>），需要由公钥进行解密（此时一般称为<strong>验签</strong>）</p>
</li>
<li><p>公钥可以公开的，大家使用公钥对信息进行加密，再发送给私钥的持有者，私钥持有者使用私钥对信息进行解密，获得信息原文。因为私钥只有单一人持有，因此不用担心被他人解密获取信息原文。</p>
</li>
</ul>
</blockquote>
<h1 id="ASCII编码"><a href="#ASCII编码" class="headerlink" title="ASCII编码"></a>ASCII编码</h1><p>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是现今最通用的单字节编码系统，并等同于国际标准ISO&#x2F;IEC 646。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250117231953414.png"
                      class="" title="image-20250117231953414"
                >

<h1 id="Byte和bit"><a href="#Byte和bit" class="headerlink" title="Byte和bit"></a>Byte和bit</h1><p>Byte : 字节. 数据存储的基本单位，比如移动硬盘1T ， 单位是byte</p>
<p>bit : 比特, 又叫位. 一个位要么是0要么是1. 数据传输的单位 , 比如家里的宽带100MB，下载速度并没有达到100MB，一般都是12-13MB，那么是因为需要使用 100 &#x2F; 8</p>
<p>关系: 1Byte &#x3D; 8bit</p>
<blockquote>
<p>中文在<strong>GBK</strong>编码下, 占据<strong>2个字节</strong><br>中文在<strong>UTF-8</strong>编码下, 占据<strong>3个字节</strong></p>
</blockquote>
<h2 id="获取字符串byte"><a href="#获取字符串byte" class="headerlink" title="获取字符串byte"></a>获取字符串byte</h2><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.asjm.bytebit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteBit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] bytes = a.getBytes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            <span class="type">int</span> c=b;</span><br><span class="line">            <span class="comment">// 打印发现byte实际上就是ascii码</span></span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250118171501107.png"
                      class="" title="image-20250118171501107"
                >

<h2 id="byte对应bit"><a href="#byte对应bit" class="headerlink" title="byte对应bit"></a>byte对应bit</h2><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.asjm.bytebit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteBit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] bytes = a.getBytes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            <span class="type">int</span> c=b;</span><br><span class="line">            <span class="comment">// 打印发现byte实际上就是ascii码</span></span><br><span class="line">            System.out.println(c);</span><br><span class="line">            <span class="comment">// 我们在来看看每个byte对应的bit，byte获取对应的bit</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Integer.toBinaryString(c);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行：打印出来应该是8个bit，但前面是0，没有打印 ，从打印结果可以看出来，一个英文字符 ，占一个字节</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250118171606909.png"
                      class="" title="image-20250118171606909"
                >

<h1 id="Base64-编码"><a href="#Base64-编码" class="headerlink" title="Base64 编码"></a>Base64 编码</h1><p>Base64 编码是一种将<strong>二进制数据</strong>转换为<strong>文本字符串</strong>的编码方式，它<strong>使用 64 个不同的 ASCII 字符</strong>来表示任意二进制数据。<strong>Base64 编码的名称源自于它使用了 64 个不同的字符来表示数据</strong></p>
<blockquote>
<p>在 Base64 编码中，每三个字节的数据（24 位）被编码为四个 Base64 字符（每个字符占 6 位），即一个字节占两个 Base64 字符。如果最后剩下不足三个字节的数据，会通过在末尾添加适当数量的填充字符（通常是 <code>=</code>）来使数据长度能够被 3 整除。</p>
<p>Base64 编码的字符集包括 <strong>大小写字母 A-Z、a-z、数字 0-9，以及两个额外字符 <code>+</code> 和 <code>/</code></strong> 。这样设计的字符集是为了在网络传输中保持数据的可读性和传输的稳定性。</p>
<p>Base64 编码常用于<strong>在文本协议中传输二进制数据</strong>，比如<strong>在电子邮件中传输附件</strong>、在 <strong>URL 中传输数据</strong>、在 <strong>JSON 格式中传输图片数据</strong>等。</p>
<p><strong>它不是加密算法，而是一种编码方式，可以将二进制数据以文本形式呈现，方便传输和存储。</strong></p>
</blockquote>
<p>下面是一个简单的示例，展示了一个字符串经过 Base64 编码后的结果：</p>
<ul>
<li>原始字符串：<code>Hello, World!</code></li>
<li>Base64 编码后的结果：<code>SGVsbG8sIFdvcmxkIQ==</code></li>
<li>base64有个 &#x3D; 号，但是在映射表里面没有发现 &#x3D; 号 ， 这个地方需要注意，等号非常特殊，因为base64是三个字节一组 ，如果当我们的位数不够的时候，会使用等号来补齐</li>
</ul>
<h2 id="base64补等号测试"><a href="#base64补等号测试" class="headerlink" title="base64补等号测试"></a>base64补等号测试</h2><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.asjm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.security.utils.Base64;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBase64</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//  1：MQ== 表示一个字节，不够三个字节，所以需要后面通过 == 号补齐</span></span><br><span class="line">        System.out.println(Base64.encode(<span class="string">&quot;1&quot;</span>.getBytes()));</span><br><span class="line"><span class="comment">//        System.out.println(Base64.encode(&quot;12&quot;.getBytes()));</span></span><br><span class="line"><span class="comment">//        System.out.println(Base64.encode(&quot;123&quot;.getBytes()));</span></span><br><span class="line"><span class="comment">//        // 硅谷:中文占6个字节，6 * 8 = 48 ，刚刚好被整除，所以没有等号</span></span><br><span class="line"><span class="comment">//        System.out.println(Base64.encode(&quot;硅谷&quot;.getBytes()));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250118173222307.png"
                      class="" title="image-20250118173222307"
                >

<p>在 JavaScript 中，可以使用 <code>btoa()</code> 函数将字符串进行 Base64 编码，使用 <code>atob()</code> 函数将 Base64 编码的字符串解码为原始字符串。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250118171121139.png"
                      class="" title="image-20250118171121139"
                >

<h1 id="常见的加密方式"><a href="#常见的加密方式" class="headerlink" title="常见的加密方式"></a>常见的加密方式</h1><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250118165302920.png"
                      class="" title="image-20250118165302920"
                >

<h1 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h1><ul>
<li>采用单钥密码系统的加密方法，<strong>同一个密钥可以同时用作信息的加密和解密</strong>，这种加密方法称为对称加密，也称为单密钥加密。</li>
<li>示例<ul>
<li>我们现在有一个原文3要发送给B</li>
<li>设置密钥为108, 3 * 108 &#x3D; 324, 将324作为密文发送给B</li>
<li>B拿到密文324后, 使用324&#x2F;108 &#x3D; 3 得到原文</li>
</ul>
</li>
<li>常见加密算法<ul>
<li><strong>DES</strong> : Data Encryption Standard，即数据加密标准，是一种使用密钥加密的块算法，1977年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），并授权在非密级政府通信中使用，随后该算法在国际上广泛流传开来。</li>
<li><strong>AES</strong> : Advanced Encryption Standard, 高级加密标准 .在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。</li>
</ul>
</li>
<li>特点<ul>
<li><strong>加密速度快, 可以加密大文件</strong></li>
<li><strong>密文可逆, 一旦密钥文件泄漏, 就会导致数据暴露</strong></li>
<li><strong>加密后编码表找不到对应字符, 出现乱码</strong></li>
<li><strong>一般结合Base64使用</strong></li>
</ul>
</li>
</ul>
<h2 id="DES加密"><a href="#DES加密" class="headerlink" title="DES加密"></a>DES加密</h2><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.asjm.desaes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DesAesDemo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: asjm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span>: 2023-09-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DesAesDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 原文</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;爱斯基摩&quot;</span>;</span><br><span class="line">        <span class="comment">// des加密必须是8位</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">        <span class="comment">// 算法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">algorithm</span> <span class="operator">=</span> <span class="string">&quot;DES&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">transformation</span> <span class="operator">=</span> <span class="string">&quot;DES&quot;</span>;</span><br><span class="line">        <span class="comment">// Cipher：密码，获取加密对象</span></span><br><span class="line">        <span class="comment">// transformation:参数表示使用什么类型加密</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(transformation);</span><br><span class="line">        <span class="comment">// 指定秘钥规则</span></span><br><span class="line">        <span class="comment">// 第一个参数表示：密钥，key的字节数组</span></span><br><span class="line">        <span class="comment">// 第二个参数表示：算法</span></span><br><span class="line">        <span class="type">SecretKeySpec</span> <span class="variable">sks</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(key.getBytes(), algorithm);</span><br><span class="line">        <span class="comment">// 对加密进行初始化</span></span><br><span class="line">        <span class="comment">// 第一个参数：表示模式，有加密模式和解密模式</span></span><br><span class="line">        <span class="comment">// 第二个参数：表示秘钥规则</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE,sks);</span><br><span class="line">        <span class="comment">// 进行加密</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = cipher.doFinal(input.getBytes());</span><br><span class="line">        <span class="comment">// 打印字节，因为ascii码有负数，解析不出来，所以乱码</span></span><br><span class="line"><span class="comment">//        for (byte b : bytes) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(b);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">// 打印密文</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行，报错：密钥是6个字节，DES加密算法规定，密钥key必须是8个字节，所以需要修改上面的key，将key改为“12345678”</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250118165827786.png"
                      class="" title="image-20250118165827786"
                >

<p>修改 密钥 key &#x3D; “12345678” ，再次运行 ，出现乱码是因为对应的字节出现负数，但负数，没有出现在 ascii 码表里面，所以出现乱码，需要配合base64进行转码</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250118170018449.png"
                      class="" title="image-20250118170018449"
                >

<p>使用 <code>base64</code> 进行编码</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.asjm.desaes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DesAesDemo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: asjm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span>: 2023-09-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DesAesDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 原文</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;爱斯基摩&quot;</span>;</span><br><span class="line">        <span class="comment">// des加密必须是8位</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;12345678&quot;</span>;</span><br><span class="line">        <span class="comment">// 算法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">algorithm</span> <span class="operator">=</span> <span class="string">&quot;DES&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">transformation</span> <span class="operator">=</span> <span class="string">&quot;DES&quot;</span>;</span><br><span class="line">        <span class="comment">// Cipher：密码，获取加密对象</span></span><br><span class="line">        <span class="comment">// transformation:参数表示使用什么类型加密</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(transformation);</span><br><span class="line">        <span class="comment">// 指定秘钥规则</span></span><br><span class="line">        <span class="comment">// 第一个参数表示：密钥，key的字节数组</span></span><br><span class="line">        <span class="comment">// 第二个参数表示：算法</span></span><br><span class="line">        <span class="type">SecretKeySpec</span> <span class="variable">sks</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(key.getBytes(), algorithm);</span><br><span class="line">        <span class="comment">// 对加密进行初始化</span></span><br><span class="line">        <span class="comment">// 第一个参数：表示模式，有加密模式和解密模式</span></span><br><span class="line">        <span class="comment">// 第二个参数：表示秘钥规则</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE,sks);</span><br><span class="line">        <span class="comment">// 进行加密</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = cipher.doFinal(input.getBytes());</span><br><span class="line">        <span class="comment">// 打印字节，因为ascii码有负数，解析不出来，所以乱码</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">encode</span> <span class="operator">=</span> Base64.encode(bytes);</span><br><span class="line">        System.out.println(encode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行:</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250118170214371.png"
                      class="" title="image-20250118170214371"
                >

<h2 id="DES解密"><a href="#DES解密" class="headerlink" title="DES解密"></a>DES解密</h2><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.asjm.desaes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.security.utils.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.IvParameterSpec;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DesDemo</span> &#123;</span><br><span class="line">    <span class="comment">// DES加密算法,key的大小必须是8个字节</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span><span class="string">&quot;爱斯基摩&quot;</span>;</span><br><span class="line">        <span class="comment">// DES加密算法，key的大小必须是8个字节</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;12345678&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">transformation</span> <span class="operator">=</span> <span class="string">&quot;DES&quot;</span>; <span class="comment">// 9PQXVUIhaaQ=</span></span><br><span class="line">        <span class="comment">// 指定获取密钥的算法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">algorithm</span> <span class="operator">=</span> <span class="string">&quot;DES&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">encryptDES</span> <span class="operator">=</span> encryptDES(input, key, transformation, algorithm);</span><br><span class="line">        System.out.println(<span class="string">&quot;加密:&quot;</span> + encryptDES);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> decryptDES(encryptDES, key, transformation, algorithm);</span><br><span class="line">        System.out.println(<span class="string">&quot;解密:&quot;</span> + s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用DES加密数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input          : 原文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key            : 密钥(DES,密钥的长度必须是8个字节)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> transformation : 获取Cipher对象的算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> algorithm      : 获取密钥的算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> : 密文</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">encryptDES</span><span class="params">(String input, String key, String transformation, String algorithm)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取加密对象</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(transformation);</span><br><span class="line">        <span class="comment">// 创建加密规则</span></span><br><span class="line">        <span class="comment">// 第一个参数key的字节</span></span><br><span class="line">        <span class="comment">// 第二个参数表示加密算法</span></span><br><span class="line">        <span class="type">SecretKeySpec</span> <span class="variable">sks</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(key.getBytes(), algorithm);</span><br><span class="line">        <span class="comment">// ENCRYPT_MODE：加密模式</span></span><br><span class="line">        <span class="comment">// DECRYPT_MODE: 解密模式</span></span><br><span class="line">        <span class="comment">// 初始化加密模式和算法</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE,sks);</span><br><span class="line">        <span class="comment">// 加密</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = cipher.doFinal(input.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出加密后的数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">encode</span> <span class="operator">=</span> Base64.encode(bytes);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> encode;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用DES解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input          : 密文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key            : 密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> transformation : 获取Cipher对象的算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> algorithm      : 获取密钥的算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: 原文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">decryptDES</span><span class="params">(String input, String key, String transformation, String algorithm)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1,获取Cipher对象</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(transformation);</span><br><span class="line">        <span class="comment">// 指定密钥规则</span></span><br><span class="line">        <span class="type">SecretKeySpec</span> <span class="variable">sks</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(key.getBytes(), algorithm);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, sks);</span><br><span class="line">        <span class="comment">// 3. 解密，上面使用的base64编码，下面直接用密文</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = cipher.doFinal(Base64.decode(input));</span><br><span class="line">        <span class="comment">//  因为是明文，所以直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="AES加密解密"><a href="#AES加密解密" class="headerlink" title="AES加密解密"></a>AES加密解密</h2><p><code>AES</code> 加密解密和 <code>DES</code> 加密解密代码一样，只需要修改加密算法就行，拷贝 <code>DES</code> 代码</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.desaes;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.security.utils.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AesDemo</span> &#123;</span><br><span class="line">    <span class="comment">// DES加密算法,key的大小必须是8个字节</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span><span class="string">&quot;爱斯基摩&quot;</span>;</span><br><span class="line">        <span class="comment">// AES加密算法，比较高级，所以key的大小必须是16个字节</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;1234567812345678&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">transformation</span> <span class="operator">=</span> <span class="string">&quot;AES&quot;</span>; <span class="comment">// 9PQXVUIhaaQ=</span></span><br><span class="line">        <span class="comment">// 指定获取密钥的算法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">algorithm</span> <span class="operator">=</span> <span class="string">&quot;AES&quot;</span>;</span><br><span class="line">        <span class="comment">// 先测试加密，然后在测试解密</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">encryptDES</span> <span class="operator">=</span> encryptDES(input, key, transformation, algorithm);</span><br><span class="line">        System.out.println(<span class="string">&quot;加密:&quot;</span> + encryptDES);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> dncryptDES(encryptDES, key, transformation, algorithm);</span><br><span class="line">        System.out.println(<span class="string">&quot;解密:&quot;</span> + s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用DES加密数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input          : 原文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key            : 密钥(DES,密钥的长度必须是8个字节)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> transformation : 获取Cipher对象的算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> algorithm      : 获取密钥的算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> : 密文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">encryptDES</span><span class="params">(String input, String key, String transformation, String algorithm)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取加密对象</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(transformation);</span><br><span class="line">        <span class="comment">// 创建加密规则</span></span><br><span class="line">        <span class="comment">// 第一个参数key的字节</span></span><br><span class="line">        <span class="comment">// 第二个参数表示加密算法</span></span><br><span class="line">        <span class="type">SecretKeySpec</span> <span class="variable">sks</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(key.getBytes(), algorithm);</span><br><span class="line">        <span class="comment">// ENCRYPT_MODE：加密模式</span></span><br><span class="line">        <span class="comment">// DECRYPT_MODE: 解密模式</span></span><br><span class="line">        <span class="comment">// 初始化加密模式和算法</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE,sks);</span><br><span class="line">        <span class="comment">// 加密</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = cipher.doFinal(input.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出加密后的数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">encode</span> <span class="operator">=</span> Base64.encode(bytes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> encode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用DES解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input          : 密文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key            : 密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> transformation : 获取Cipher对象的算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> algorithm      : 获取密钥的算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: 原文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">dncryptDES</span><span class="params">(String input, String key, String transformation, String algorithm)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1,获取Cipher对象</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(transformation);</span><br><span class="line">        <span class="comment">// 指定密钥规则</span></span><br><span class="line">        <span class="type">SecretKeySpec</span> <span class="variable">sks</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(key.getBytes(), algorithm);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, sks);</span><br><span class="line">        <span class="comment">// 3. 解密</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = cipher.doFinal(Base64.decode(input));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="加密模式"><a href="#加密模式" class="headerlink" title="加密模式"></a>加密模式</h2><p>加密模式：<code>https://docs.oracle.com/javase/8/docs/api/javax/crypto/Cipher.html</code></p>
<h3 id="ECB"><a href="#ECB" class="headerlink" title="ECB"></a>ECB</h3><p>ECB : Electronic codebook, 电子密码本. 需要加密的消息<strong>按照块密码的块大小</strong>被分为数个块，并对<strong>每个块进行独立加密</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250118212337760.png"
                      class="" title="image-20250118212337760"
                >

<ul>
<li>优点 : 可以并行处理数据</li>
<li>缺点 : 同样的原文生成同样的密文, 不能很好的保护数据</li>
<li>同时加密，原文是一样的，加密出来的密文也是一样的</li>
</ul>
<h3 id="CBC"><a href="#CBC" class="headerlink" title="CBC"></a>CBC</h3><p>CBC : Cipher-block chaining, 密码块链接. 每个明文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有明文块</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250118213544953.png"
                      class="" title="image-20250118213544953"
                >

<ul>
<li>优点 : 同样的原文生成的密文不一样</li>
<li>缺点 : 串行处理数据.</li>
</ul>
<h2 id="填充模式"><a href="#填充模式" class="headerlink" title="填充模式"></a>填充模式</h2><p>当需要按块处理的数据, 数据长度不符合块处理需求时, 按照一定的方法填充满块长的规则</p>
<h3 id="NoPadding"><a href="#NoPadding" class="headerlink" title="NoPadding"></a>NoPadding</h3><ul>
<li>不填充.</li>
<li>在DES加密算法下, 要求原文长度必须是8byte的整数倍</li>
<li>在AES加密算法下, 要求原文长度必须是16byte的整数倍</li>
</ul>
<h3 id="PKCS5Padding"><a href="#PKCS5Padding" class="headerlink" title="PKCS5Padding"></a>PKCS5Padding</h3><p>数据块的大小为8位, 不够就补足</p>
<blockquote>
<ul>
<li>默认情况下, <strong>加密模式和填充模式为 : ECB&#x2F;PKCS5Padding</strong></li>
<li>如果使用CBC模式, 在初始化Cipher对象时, 需要增加参数, 初始化向量IV : IvParameterSpec iv &#x3D; new IvParameterSpec(key.getBytes());</li>
</ul>
</blockquote>
<p>加密模式和填充模式</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">AES/CBC/NoPadding (128)</span><br><span class="line">AES/CBC/PKCS5Padding (128)</span><br><span class="line">AES/ECB/NoPadding (128)</span><br><span class="line">AES/ECB/PKCS5Padding (128)</span><br><span class="line">DES/CBC/NoPadding (56)</span><br><span class="line">DES/CBC/PKCS5Padding (56)</span><br><span class="line">DES/ECB/NoPadding (56)</span><br><span class="line">DES/ECB/PKCS5Padding (56)</span><br><span class="line">DESede/CBC/NoPadding (168)</span><br><span class="line">DESede/CBC/PKCS5Padding (168)</span><br><span class="line">DESede/ECB/NoPadding (168)</span><br><span class="line">DESede/ECB/PKCS5Padding (168)</span><br><span class="line">RSA/ECB/PKCS1Padding (1024, 2048)</span><br><span class="line">RSA/ECB/OAEPWithSHA-1AndMGF1Padding (1024, 2048)</span><br><span class="line">RSA/ECB/OAEPWithSHA-256AndMGF1Padding (1024, 2048)</span><br></pre></td></tr></table></figure></div>

<p>加密模式和填充模式例子</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.desaes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.security.utils.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.IvParameterSpec;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DesDemo</span> &#123;</span><br><span class="line">    <span class="comment">// DES加密算法,key的大小必须是8个字节</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span><span class="string">&quot;爱斯基摩&quot;</span>;</span><br><span class="line">        <span class="comment">// DES加密算法，key的大小必须是8个字节</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;12345678&quot;</span>;</span><br><span class="line">        <span class="comment">// 指定获取Cipher的算法,如果没有指定加密模式和填充模式,ECB/PKCS5Padding就是默认值</span></span><br><span class="line">        <span class="comment">//String transformation = &quot;DES&quot;; </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">transformation</span> <span class="operator">=</span> <span class="string">&quot;DES/ECB/PKCS5Padding&quot;</span>; </span><br><span class="line">        <span class="comment">// 指定获取密钥的算法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">algorithm</span> <span class="operator">=</span> <span class="string">&quot;DES&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">encryptDES</span> <span class="operator">=</span> encryptDES(input, key, transformation, algorithm);</span><br><span class="line">        System.out.println(<span class="string">&quot;加密:&quot;</span> + encryptDES);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> dncryptDES(encryptDES, key, transformation, algorithm);</span><br><span class="line">        System.out.println(<span class="string">&quot;解密:&quot;</span> + s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用DES加密数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input          : 原文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key            : 密钥(DES,密钥的长度必须是8个字节)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> transformation : 获取Cipher对象的算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> algorithm      : 获取密钥的算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> : 密文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">encryptDES</span><span class="params">(String input, String key, String transformation, String algorithm)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取加密对象</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(transformation);</span><br><span class="line">        <span class="comment">// 创建加密规则</span></span><br><span class="line">        <span class="comment">// 第一个参数key的字节</span></span><br><span class="line">        <span class="comment">// 第二个参数表示加密算法</span></span><br><span class="line">        <span class="type">SecretKeySpec</span> <span class="variable">sks</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(key.getBytes(), algorithm);</span><br><span class="line">        <span class="comment">// ENCRYPT_MODE：加密模式</span></span><br><span class="line">        <span class="comment">// DECRYPT_MODE: 解密模式</span></span><br><span class="line">         <span class="comment">// 初始化加密模式和算法</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE,sks);</span><br><span class="line">        <span class="comment">// 加密</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = cipher.doFinal(input.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出加密后的数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">encode</span> <span class="operator">=</span> Base64.encode(bytes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> encode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用DES解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input          : 密文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key            : 密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> transformation : 获取Cipher对象的算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> algorithm      : 获取密钥的算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: 原文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">dncryptDES</span><span class="params">(String input, String key, String transformation, String algorithm)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1,获取Cipher对象</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(transformation);</span><br><span class="line">        <span class="comment">// 指定密钥规则</span></span><br><span class="line">        <span class="type">SecretKeySpec</span> <span class="variable">sks</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(key.getBytes(), algorithm);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, sks);</span><br><span class="line">        <span class="comment">// 3. 解密</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = cipher.doFinal(Base64.decode(input));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>修改成 <code>CBC</code> 加密 模式</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">transformation</span> <span class="operator">=</span> <span class="string">&quot;DES/CBC/PKCS5Padding&quot;</span>;</span><br></pre></td></tr></table></figure></div>

<p>运行 ，报错，需要添加一个参数</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250119221341814.png"
                      class="" title="image-20250119221341814"
                >

<p>修改加密代码：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.asjm.desaes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.security.utils.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.IvParameterSpec;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DesDemo</span> &#123;</span><br><span class="line">    <span class="comment">// DES加密算法,key的大小必须是8个字节</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span><span class="string">&quot;爱斯基摩&quot;</span>;</span><br><span class="line">        <span class="comment">// DES加密算法，key的大小必须是8个字节</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;12345678&quot;</span>;</span><br><span class="line">        <span class="comment">// CBC模式,必须指定初始向量,初始向量中密钥的长度必须是8个字节</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">transformation</span> <span class="operator">=</span> <span class="string">&quot;DES/CBC/PKCS5Padding&quot;</span>;</span><br><span class="line">        <span class="comment">// 指定获取密钥的算法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">algorithm</span> <span class="operator">=</span> <span class="string">&quot;DES&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">encryptDES</span> <span class="operator">=</span> encryptDES(input, key, transformation, algorithm);</span><br><span class="line">        System.out.println(<span class="string">&quot;加密:&quot;</span> + encryptDES);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> dncryptDES(encryptDES, key, transformation, algorithm);</span><br><span class="line">        System.out.println(<span class="string">&quot;解密:&quot;</span> + s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用DES加密数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input          : 原文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key            : 密钥(DES,密钥的长度必须是8个字节)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> transformation : 获取Cipher对象的算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> algorithm      : 获取密钥的算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> : 密文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">encryptDES</span><span class="params">(String input, String key, String transformation, String algorithm)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取加密对象</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(transformation);</span><br><span class="line">        <span class="comment">// 创建加密规则</span></span><br><span class="line">        <span class="comment">// 第一个参数key的字节</span></span><br><span class="line">        <span class="comment">// 第二个参数表示加密算法</span></span><br><span class="line">        <span class="type">SecretKeySpec</span> <span class="variable">sks</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(key.getBytes(), algorithm);</span><br><span class="line">        <span class="comment">// ENCRYPT_MODE：加密模式</span></span><br><span class="line">        <span class="comment">// DECRYPT_MODE: 解密模式</span></span><br><span class="line">         <span class="comment">// 初始向量，参数表示跟谁进行异或，初始向量的长度必须是8位</span></span><br><span class="line">        <span class="type">IvParameterSpec</span> <span class="variable">iv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IvParameterSpec</span>(key.getBytes());</span><br><span class="line">         <span class="comment">// 初始化加密模式和算法</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE,sks,iv);</span><br><span class="line">        <span class="comment">// 加密</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = cipher.doFinal(input.getBytes());</span><br><span class="line">        <span class="comment">// 输出加密后的数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">encode</span> <span class="operator">=</span> Base64.encode(bytes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> encode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用DES解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input          : 密文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key            : 密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> transformation : 获取Cipher对象的算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> algorithm      : 获取密钥的算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: 原文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">dncryptDES</span><span class="params">(String input, String key, String transformation, String algorithm)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1,获取Cipher对象</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(transformation);</span><br><span class="line">        <span class="comment">// 指定密钥规则</span></span><br><span class="line">        <span class="type">SecretKeySpec</span> <span class="variable">sks</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(key.getBytes(), algorithm);</span><br><span class="line">        <span class="comment">//添加解密向量</span></span><br><span class="line">        <span class="type">IvParameterSpec</span> <span class="variable">iv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IvParameterSpec</span>(key.getBytes());</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, sks,iv);</span><br><span class="line">        <span class="comment">// 3. 解密</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = cipher.doFinal(Base64.decode(input));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>修改填充模式</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">String transformation = &quot;DES/CBC/NoPadding&quot;;</span><br></pre></td></tr></table></figure></div>

<p>运行报错 <code>NoPadding</code> 这种填充模式 原文必须是8个字节的整倍数</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250119221314490.png"
                      class="" title="image-20250119221314490"
                >

<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="comment">//UTF-8编码下，一个中文占3个字节</span></span><br><span class="line">    <span class="comment">//原文又必须是8个字节整倍数，加上1234，刚好16个字节，满足条件</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span><span class="string">&quot;爱斯基摩1234&quot;</span>;</span><br><span class="line">    <span class="comment">// DES加密算法，key的大小必须是8个字节</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;12345678&quot;</span>;</span><br><span class="line">    <span class="comment">// CBC模式,必须指定初始向量,初始向量中密钥的长度必须是8个字节</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">transformation</span> <span class="operator">=</span> <span class="string">&quot;DES/CBC/NoPadding&quot;</span>; </span><br><span class="line">    <span class="comment">// 指定获取密钥的算法</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">algorithm</span> <span class="operator">=</span> <span class="string">&quot;DES&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">encryptDES</span> <span class="operator">=</span> encryptDES(input, key, transformation, algorithm);</span><br><span class="line">    System.out.println(<span class="string">&quot;加密:&quot;</span> + encryptDES);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> dncryptDES(encryptDES, key, transformation, algorithm);</span><br><span class="line">    System.out.println(<span class="string">&quot;解密:&quot;</span> + s);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>在测试 <code>AES</code> 的时候需要注意，key需要16个字节，加密向量也需要16个字节 ，其他方式跟 <code>DES</code> 一样</strong></p>
<h1 id="消息摘要"><a href="#消息摘要" class="headerlink" title="消息摘要"></a>消息摘要</h1><ul>
<li>MD5（Message Digest Algorithm 5）是一种哈希函数，而不是加密算法。哈希函数是一种单向函数，它将输入数据转换为固定长度的输出，通常用于<strong>创建数据摘要</strong>、<strong>校验数据完整性</strong>，或者<strong>创建唯一的标识符</strong></li>
<li>消息摘要（Message Digest）又称为数字摘要(Digital Digest)</li>
<li>它是一个唯一对应一个消息或文本的固定长度的值，它由一个<strong>单向Hash加密函数</strong>对消息进行作用而产生</li>
<li>使用数字摘要生成的值是不可以篡改的，为了保证文件或者值的安全</li>
</ul>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>无论输入的消息有多长，计算出来的消息摘要的<strong>长度总是固定</strong>的。例如应用<strong>MD5算法</strong>摘要的消息有<strong>128个比特位</strong>，用<strong>SHA-1算法</strong>摘要的消息最终有<strong>160比特位</strong>的输出</p>
<p>只要输入的消息不同，对其进行摘要以后产生的摘要消息也必不相同；但<strong>相同的输入</strong>必会<strong>产生相同的摘要</strong></p>
<p><strong>消息摘要是单向、不可逆的</strong></p>
<p>常见算法 :</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">- MD5</span><br><span class="line">- SHA1</span><br><span class="line">- SHA256</span><br><span class="line">- SHA512</span><br></pre></td></tr></table></figure></div>

<h2 id="在线获取消息摘要"><a href="#在线获取消息摘要" class="headerlink" title="在线获取消息摘要"></a>在线获取消息摘要</h2><p>百度搜索 <code>tomcat</code> ，进入官网下载 ，会经常发现有 <code>sha1</code>，<code>sha512</code> , 这些都是数字摘要</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250119223455962.png"
                      class="" title="image-20250119223455962"
                >

<p>数字摘要</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250119223513345.png"
                      class="" title="image-20250119223513345"
                >

<h2 id="获取字符串消息摘要"><a href="#获取字符串消息摘要" class="headerlink" title="获取字符串消息摘要"></a>获取字符串消息摘要</h2><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.asjm.digest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sound.midi.Soundbank;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DigestDemo1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 原文</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;aa&quot;</span>;</span><br><span class="line">        <span class="comment">// 算法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">algorithm</span> <span class="operator">=</span> <span class="string">&quot;MD5&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取数字摘要对象</span></span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">messageDigest</span> <span class="operator">=</span> MessageDigest.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 获取消息数字摘要的字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] digest = messageDigest.digest(input.getBytes());</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(digest));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行，出现乱码</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250119223554910.png"
                      class="" title="image-20250119223554910"
                >

<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.asjm.digest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.security.utils.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sound.midi.Soundbank;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DigestDemo1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 原文</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;aa&quot;</span>;</span><br><span class="line">        <span class="comment">// 算法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">algorithm</span> <span class="operator">=</span> <span class="string">&quot;MD5&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取数字摘要对象</span></span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">messageDigest</span> <span class="operator">=</span> MessageDigest.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 消息数字摘要</span></span><br><span class="line">        <span class="type">byte</span>[] digest = messageDigest.digest(input.getBytes());</span><br><span class="line"><span class="comment">//        System.out.println(new String(digest));</span></span><br><span class="line">        <span class="comment">// base64编码</span></span><br><span class="line">        System.out.println(Base64.encode(digest));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行，结果正常</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250119223722416.png"
                      class="" title="image-20250119223722416"
                >

<p>使用在线 md5 加密 ，发现我们生成的值和代码生成的值不一样，那是因为消息摘要不是使用base64进行编码的，通常在计算哈希值时，会以十六进制形式表示结果。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250119223736727.png"
                      class="" title="image-20250119223736727"
                >

<p>既然如此，修改代码，将生成的摘要转换为16进制：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.asjm.digest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.security.utils.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sound.midi.Soundbank;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DigestDemo1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 4124bc0a9335c27f086f24ba207a4912     md5 在线校验</span></span><br><span class="line">        <span class="comment">// QSS8CpM1wn8IbyS6IHpJEg==             消息摘要使用的是16进制</span></span><br><span class="line">        <span class="comment">// 原文</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;aa&quot;</span>;</span><br><span class="line">        <span class="comment">// 算法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">algorithm</span> <span class="operator">=</span> <span class="string">&quot;MD5&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取数字摘要对象</span></span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">messageDigest</span> <span class="operator">=</span> MessageDigest.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 消息数字摘要</span></span><br><span class="line">        <span class="type">byte</span>[] digest = messageDigest.digest(input.getBytes());</span><br><span class="line"><span class="comment">//        System.out.println(new String(digest));</span></span><br><span class="line">        <span class="comment">// base64编码</span></span><br><span class="line"><span class="comment">//        System.out.println(Base64.encode(digest));</span></span><br><span class="line">        <span class="comment">// 创建对象用来拼接</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : digest) &#123;</span><br><span class="line">            <span class="comment">// 转成 16进制</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Integer.toHexString(b &amp; <span class="number">0xff</span>);</span><br><span class="line">            <span class="comment">//System.out.println(s);</span></span><br><span class="line">            <span class="keyword">if</span> (s.length() == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 如果生成的字符只有一个，前面补0</span></span><br><span class="line">                s = <span class="string">&quot;0&quot;</span>+s;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>得到结果：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250120000213421.png"
                      class="" title="image-20250120000213421"
                >

<h2 id="其他数字摘要算法"><a href="#其他数字摘要算法" class="headerlink" title="其他数字摘要算法"></a>其他数字摘要算法</h2><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.asjm.digest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.security.utils.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sound.midi.Soundbank;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DigestDemo1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 4124bc0a9335c27f086f24ba207a4912     md5 在线校验</span></span><br><span class="line">        <span class="comment">// QSS8CpM1wn8IbyS6IHpJEg==             消息摘要使用的是16进制</span></span><br><span class="line">        <span class="comment">// 原文</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;aa&quot;</span>;</span><br><span class="line">        <span class="comment">// 算法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">algorithm</span> <span class="operator">=</span> <span class="string">&quot;MD5&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取数字摘要对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">md5</span> <span class="operator">=</span> getDigest(input, <span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        System.out.println(md5);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sha1</span> <span class="operator">=</span> getDigest(input, <span class="string">&quot;SHA-1&quot;</span>);</span><br><span class="line">        System.out.println(sha1);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sha256</span> <span class="operator">=</span> getDigest(input, <span class="string">&quot;SHA-256&quot;</span>);</span><br><span class="line">        System.out.println(sha256);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sha512</span> <span class="operator">=</span> getDigest(input, <span class="string">&quot;SHA-512&quot;</span>);</span><br><span class="line">        System.out.println(sha512);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">toHex</span><span class="params">(<span class="type">byte</span>[] digest)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(new String(digest));</span></span><br><span class="line">        <span class="comment">// base64编码</span></span><br><span class="line"><span class="comment">//        System.out.println(Base64.encode(digest));</span></span><br><span class="line">        <span class="comment">// 创建对象用来拼接</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : digest) &#123;</span><br><span class="line">            <span class="comment">// 转成 16进制</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Integer.toHexString(b &amp; <span class="number">0xff</span>);</span><br><span class="line">            <span class="keyword">if</span> (s.length() == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 如果生成的字符只有一个，前面补0</span></span><br><span class="line">                s = <span class="string">&quot;0&quot;</span>+s;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;16进制数据的长度：&quot;</span> + sb.toString().getBytes().length);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getDigest</span><span class="params">(String input, String algorithm)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">messageDigest</span> <span class="operator">=</span> MessageDigest.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 消息数字摘要</span></span><br><span class="line">        <span class="type">byte</span>[] digest = messageDigest.digest(input.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;密文的字节长度:&quot;</span> + digest.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> toHex(digest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>得到结果：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250120000330219.png"
                      class="" title="image-20250120000330219"
                >

<h2 id="获取文件摘要"><a href="#获取文件摘要" class="headerlink" title="获取文件摘要"></a>获取文件摘要</h2><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.asjm.digest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.security.utils.Base64;</span><br><span class="line"><span class="keyword">import</span> com.sun.scenario.effect.impl.sw.sse.SSEBlend_SRC_OUTPeer;</span><br><span class="line"><span class="keyword">import</span> sun.misc.BASE64Decoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DigestDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;aa&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">algorithm</span> <span class="operator">=</span> <span class="string">&quot;MD5&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sha1 可以实现秒传功能</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sha1</span> <span class="operator">=</span> getDigestFile(<span class="string">&quot;apache-tomcat-9.0.10-windows-x64.zip&quot;</span>, <span class="string">&quot;SHA-1&quot;</span>);</span><br><span class="line">        System.out.println(sha1);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sha512</span> <span class="operator">=</span> getDigestFile(<span class="string">&quot;apache-tomcat-9.0.10-windows-x64.zip&quot;</span>, <span class="string">&quot;SHA-512&quot;</span>);</span><br><span class="line">        System.out.println(sha512);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">md5</span> <span class="operator">=</span> getDigest(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        System.out.println(md5);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">md51</span> <span class="operator">=</span> getDigest(<span class="string">&quot;aa &quot;</span>, <span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        System.out.println(md51);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getDigestFile</span><span class="params">(String filePath, String algorithm)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="keyword">while</span> ( (len =  fis.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            baos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取消息摘要对象</span></span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">messageDigest</span> <span class="operator">=</span> MessageDigest.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 获取消息摘要</span></span><br><span class="line">        <span class="type">byte</span>[] digest = messageDigest.digest(baos.toByteArray());</span><br><span class="line">        System.out.println(<span class="string">&quot;密文的字节长度：&quot;</span>+digest.length);</span><br><span class="line">        <span class="keyword">return</span> toHex(digest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getDigest</span><span class="params">(String input, String algorithm)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">messageDigest</span> <span class="operator">=</span> MessageDigest.getInstance(algorithm);</span><br><span class="line">        <span class="type">byte</span>[] digest = messageDigest.digest(input.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;密文的字节长度：&quot;</span>+digest.length);</span><br><span class="line">        <span class="keyword">return</span> toHex(digest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">toHex</span><span class="params">(<span class="type">byte</span>[] digest)</span> &#123;</span><br><span class="line">        <span class="comment">//        System.out.println(new String(digest));</span></span><br><span class="line">        <span class="comment">// 消息摘要进行表示的时候，是用16进制进行表示</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : digest) &#123;</span><br><span class="line">            <span class="comment">// 转成16进制</span></span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Integer.toHexString(b &amp; <span class="number">0xff</span>);</span><br><span class="line">            <span class="comment">// 保持数据的完整性，前面不够的用0补齐</span></span><br><span class="line">            <span class="keyword">if</span> (s.length()==<span class="number">1</span>)&#123;</span><br><span class="line">                s=<span class="string">&quot;0&quot;</span>+s;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;16进制数据的长度:&quot;</span>+ sb.toString().getBytes().length);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行程序 ，获取 <code>sha-1</code> 和 <code>sha-512</code> 的值</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250120002025510.png"
                      class="" title="image-20250120002025510"
                >

<p>查看 tomcat 官网上面 <code>sha-1</code> 和 <code>sha-512</code> 的值</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250120002038754.png"
                      class="" title="image-20250120002038754"
                >

<p>使用 sha-1 算法，可以实现秒传功能，不管咱们如何修改文件的名字，最后得到的值是一样的</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250120002121548.png"
                      class="" title="image-20250120002121548"
                >

<p>运行程序 ，获取 <code>sha-1</code> 和 <code>sha-512</code> 的值</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250120002341682.png"
                      class="" title="image-20250120002341682"
                >

<p>如果原文修改了，那么sha-1值 就会不一样</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250120002400231.png"
                      class="" title="image-20250120002400231"
                >

<p>运行结果：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250120002413050.png"
                      class="" title="image-20250120002413050"
                ></p>
<p>总结</p>
<ul>
<li>MD5算法 : 摘要结果16个字节, 转16进制后32个字节</li>
<li>SHA1算法 : 摘要结果20个字节, 转16进制后40个字节</li>
<li>SHA256算法 : 摘要结果32个字节, 转16进制后64个字节</li>
<li>SHA512算法 : 摘要结果64个字节, 转16进制后128个字节</li>
</ul>
<h1 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h1><p>① 非对称加密算法又称<code>现代加密算法</code>。</p>
<p>② 非对称加密是计算机通信安全的基石，保证了加密数据<code>不会被破解</code>。</p>
<p>③ 与对称加密算法不同，非对称加密算法需要两个密钥：<code>公开密钥(publickey)</code> 和<code>私有密(privatekey)</code></p>
<p>④ 公开密钥和私有密钥是<code>一对</code></p>
<p>⑤ 如果用<code>公开密钥</code>对数据进行<code>加密</code>，只有用<code>对应的私有密钥</code>才能<code>解密</code>。</p>
<p>⑥ 如果用<code>私有密钥</code>对数据进行<code>加密</code>，只有用<code>对应的公开密钥</code>才能<code>解密</code>。</p>
<p>⑦ 因为加密和解密使用的是两个<code>不同</code>的密钥，所以这种算法叫作<code>非对称加密算法</code>。</p>
<ul>
<li>示例<ul>
<li>首先生成密钥对, 公钥为(5,14), 私钥为(11,14)</li>
<li>现在A希望将原文2发送给B</li>
<li>A使用公钥加密数据. 2的5次方mod 14 &#x3D; 4 , 将密文4发送给B</li>
<li>B使用私钥解密数据. 4的11次方mod14 &#x3D; 2, 得到原文2</li>
</ul>
</li>
<li>特点<ul>
<li>加密和解密使用不同的密钥</li>
<li>如果使用私钥加密, 只能使用公钥解密</li>
<li>如果使用公钥加密, 只能使用私钥解密</li>
<li>处理数据的速度较慢, 因为安全级别高</li>
</ul>
</li>
<li>常见算法<ul>
<li>RSA</li>
<li>ECC</li>
</ul>
</li>
</ul>
<h2 id="生成私钥和公钥"><a href="#生成私钥和公钥" class="headerlink" title="生成私钥和公钥"></a>生成私钥和公钥</h2><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.asjm.rsa;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.security.utils.Base64;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RSAdemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 加密算法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">algorithm</span> <span class="operator">=</span> <span class="string">&quot;RSA&quot;</span>;</span><br><span class="line">        <span class="comment">//  创建密钥对生成器对象</span></span><br><span class="line">        <span class="type">KeyPairGenerator</span> <span class="variable">keyPairGenerator</span> <span class="operator">=</span> KeyPairGenerator.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 生成密钥对</span></span><br><span class="line">        <span class="type">KeyPair</span> <span class="variable">keyPair</span> <span class="operator">=</span> keyPairGenerator.generateKeyPair();</span><br><span class="line">        <span class="comment">// 生成私钥</span></span><br><span class="line">        <span class="type">PrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> keyPair.getPrivate();</span><br><span class="line">        <span class="comment">// 生成公钥</span></span><br><span class="line">        <span class="type">PublicKey</span> <span class="variable">publicKey</span> <span class="operator">=</span> keyPair.getPublic();</span><br><span class="line">        <span class="comment">// 获取私钥字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] privateKeyEncoded = privateKey.getEncoded();</span><br><span class="line">        <span class="comment">// 获取公钥字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] publicKeyEncoded = publicKey.getEncoded();</span><br><span class="line">        <span class="comment">// 对公私钥进行base64编码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">privateKeyString</span> <span class="operator">=</span> Base64.encode(privateKeyEncoded);</span><br><span class="line">        <span class="type">String</span> <span class="variable">publicKeyString</span> <span class="operator">=</span> Base64.encode(publicKeyEncoded);</span><br><span class="line">        <span class="comment">// 打印私钥</span></span><br><span class="line">        System.out.println(privateKeyString);</span><br><span class="line">        <span class="comment">// 打印公钥</span></span><br><span class="line">        System.out.println(publicKeyString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行程序：先打印的是私钥 ， 后面打印的是公钥</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250120101633623.png"
                      class="" title="image-20250120101633623"
                >

<h2 id="私钥加密公钥解密"><a href="#私钥加密公钥解密" class="headerlink" title="私钥加密公钥解密"></a>私钥加密公钥解密</h2><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.rsa;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.security.utils.Base64;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RSAdemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;爱斯基摩&quot;</span>;</span><br><span class="line">        <span class="comment">// 加密算法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">algorithm</span> <span class="operator">=</span> <span class="string">&quot;RSA&quot;</span>;</span><br><span class="line">        <span class="comment">//  创建密钥对生成器对象</span></span><br><span class="line">        <span class="type">KeyPairGenerator</span> <span class="variable">keyPairGenerator</span> <span class="operator">=</span> KeyPairGenerator.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 生成密钥对</span></span><br><span class="line">        <span class="type">KeyPair</span> <span class="variable">keyPair</span> <span class="operator">=</span> keyPairGenerator.generateKeyPair();</span><br><span class="line">        <span class="comment">// 生成私钥</span></span><br><span class="line">        <span class="type">PrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> keyPair.getPrivate();</span><br><span class="line">        <span class="comment">// 生成公钥</span></span><br><span class="line">        <span class="type">PublicKey</span> <span class="variable">publicKey</span> <span class="operator">=</span> keyPair.getPublic();</span><br><span class="line">        <span class="comment">// 获取私钥字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] privateKeyEncoded = privateKey.getEncoded();</span><br><span class="line">        <span class="comment">// 获取公钥字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] publicKeyEncoded = publicKey.getEncoded();</span><br><span class="line">        <span class="comment">// 对公私钥进行base64编码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">privateKeyString</span> <span class="operator">=</span> Base64.encode(privateKeyEncoded);</span><br><span class="line">        <span class="type">String</span> <span class="variable">publicKeyString</span> <span class="operator">=</span> Base64.encode(publicKeyEncoded);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建加密对象</span></span><br><span class="line">        <span class="comment">// 参数表示加密算法</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 初始化加密</span></span><br><span class="line">        <span class="comment">// 第一个参数:加密的模式</span></span><br><span class="line">        <span class="comment">// 第二个参数：使用私钥进行加密</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE,privateKey);</span><br><span class="line">        <span class="comment">// 私钥加密</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = cipher.doFinal(input.getBytes());</span><br><span class="line">        System.out.println(Base64.encode(bytes));</span><br><span class="line">        <span class="comment">// 私钥进行解密</span></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE,publicKey);</span><br><span class="line">        <span class="comment">// 对密文进行解密，不需要使用base64，因为原文不会乱码</span></span><br><span class="line">        <span class="type">byte</span>[] bytes1 = cipher.doFinal(bytes);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes1));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="保存公钥和私钥"><a href="#保存公钥和私钥" class="headerlink" title="保存公钥和私钥"></a>保存公钥和私钥</h2><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.asjm.rsa;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.security.utils.Base64;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RSAdemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 加密算法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">algorithm</span> <span class="operator">=</span> <span class="string">&quot;RSA&quot;</span>;</span><br><span class="line">        <span class="comment">//生成密钥对并保存在本地文件中</span></span><br><span class="line">        generateKeyToFile(algorithm, <span class="string">&quot;a.pub&quot;</span>, <span class="string">&quot;a.pri&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成密钥对并保存在本地文件中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> algorithm : 算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pubPath   : 公钥保存路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> priPath   : 私钥保存路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">generateKeyToFile</span><span class="params">(String algorithm, String pubPath, String priPath)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取密钥对生成器</span></span><br><span class="line">        <span class="type">KeyPairGenerator</span> <span class="variable">keyPairGenerator</span> <span class="operator">=</span> KeyPairGenerator.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 获取密钥对</span></span><br><span class="line">        <span class="type">KeyPair</span> <span class="variable">keyPair</span> <span class="operator">=</span> keyPairGenerator.generateKeyPair();</span><br><span class="line">        <span class="comment">// 获取公钥</span></span><br><span class="line">        <span class="type">PublicKey</span> <span class="variable">publicKey</span> <span class="operator">=</span> keyPair.getPublic();</span><br><span class="line">        <span class="comment">// 获取私钥</span></span><br><span class="line">        <span class="type">PrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> keyPair.getPrivate();</span><br><span class="line">        <span class="comment">// 获取byte数组</span></span><br><span class="line">        <span class="type">byte</span>[] publicKeyEncoded = publicKey.getEncoded();</span><br><span class="line">        <span class="type">byte</span>[] privateKeyEncoded = privateKey.getEncoded();</span><br><span class="line">        <span class="comment">// 进行Base64编码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">publicKeyString</span> <span class="operator">=</span> Base64.encode(publicKeyEncoded);</span><br><span class="line">        <span class="type">String</span> <span class="variable">privateKeyString</span> <span class="operator">=</span> Base64.encode(privateKeyEncoded);</span><br><span class="line">        <span class="comment">// 保存文件</span></span><br><span class="line">        FileUtils.writeStringToFile(<span class="keyword">new</span> <span class="title class_">File</span>(pubPath), publicKeyString, Charset.forName(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        FileUtils.writeStringToFile(<span class="keyword">new</span> <span class="title class_">File</span>(priPath), privateKeyString, Charset.forName(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> algorithm      : 算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encrypted      : 密文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key            : 密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> : 原文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">decryptRSA</span><span class="params">(String algorithm,Key key,String encrypted)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">         <span class="comment">// 创建加密对象</span></span><br><span class="line">        <span class="comment">// 参数表示加密算法</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 私钥进行解密</span></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE,key);</span><br><span class="line">        <span class="comment">// 由于密文进行了Base64编码, 在这里需要进行解码</span></span><br><span class="line">        <span class="type">byte</span>[] decode = Base64.decode(encrypted);</span><br><span class="line">        <span class="comment">// 对密文进行解密，不需要使用base64，因为原文不会乱码</span></span><br><span class="line">        <span class="type">byte</span>[] bytes1 = cipher.doFinal(decode);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes1));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用密钥加密数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> algorithm      : 算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input          : 原文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key            : 密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> : 密文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">encryptRSA</span><span class="params">(String algorithm,Key key,String input)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 创建加密对象</span></span><br><span class="line">        <span class="comment">// 参数表示加密算法</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 初始化加密</span></span><br><span class="line">        <span class="comment">// 第一个参数:加密的模式</span></span><br><span class="line">        <span class="comment">// 第二个参数：使用私钥进行加密</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE,key);</span><br><span class="line">        <span class="comment">// 私钥加密</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = cipher.doFinal(input.getBytes());</span><br><span class="line">        <span class="comment">// 对密文进行Base64编码</span></span><br><span class="line">        System.out.println(Base64.encode(bytes));</span><br><span class="line">        <span class="keyword">return</span> Base64.encode(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行在项目根目录生成私钥</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250120152735843.png"
                      class="" title="image-20250120152735843"
                >

<p>运行在项目根目录生成公钥</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250120152753752.png"
                      class="" title="image-20250120152753752"
                >

<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.asjm.rsa;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.security.utils.Base64;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.X509EncodedKeySpec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RSAdemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;硅谷&quot;</span>;</span><br><span class="line">        <span class="comment">// 加密算法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">algorithm</span> <span class="operator">=</span> <span class="string">&quot;RSA&quot;</span>;</span><br><span class="line">        <span class="type">PrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> getPrivateKey(<span class="string">&quot;a.pri&quot;</span>, algorithm);</span><br><span class="line">        <span class="type">PublicKey</span> <span class="variable">publicKey</span> <span class="operator">=</span> getPublicKey(<span class="string">&quot;a.pub&quot;</span>, algorithm);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> encryptRSA(algorithm, privateKey, input);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> decryptRSA(algorithm, publicKey, s);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PublicKey <span class="title function_">getPublicKey</span><span class="params">(String pulickPath,String algorithm)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 将文件内容转为字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">publicKeyString</span> <span class="operator">=</span> FileUtils.readFileToString(<span class="keyword">new</span> <span class="title class_">File</span>(pulickPath), Charset.defaultCharset());</span><br><span class="line">        <span class="comment">// 获取密钥工厂</span></span><br><span class="line">        <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 构建密钥规范 进行Base64解码</span></span><br><span class="line">        <span class="type">X509EncodedKeySpec</span> <span class="variable">spec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X509EncodedKeySpec</span>(Base64.decode(publicKeyString));</span><br><span class="line">        <span class="comment">// 生成公钥</span></span><br><span class="line">        <span class="keyword">return</span> keyFactory.generatePublic(spec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PrivateKey <span class="title function_">getPrivateKey</span><span class="params">(String priPath,String algorithm)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 将文件内容转为字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">privateKeyString</span> <span class="operator">=</span> FileUtils.readFileToString(<span class="keyword">new</span> <span class="title class_">File</span>(priPath), Charset.defaultCharset());</span><br><span class="line">        <span class="comment">// 获取密钥工厂</span></span><br><span class="line">        <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 构建密钥规范 进行Base64解码</span></span><br><span class="line">        <span class="type">PKCS8EncodedKeySpec</span> <span class="variable">spec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PKCS8EncodedKeySpec</span>(Base64.decode(privateKeyString));</span><br><span class="line">        <span class="comment">// 生成私钥</span></span><br><span class="line">        <span class="keyword">return</span> keyFactory.generatePrivate(spec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成密钥对并保存在本地文件中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> algorithm : 算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pubPath   : 公钥保存路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> priPath   : 私钥保存路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">generateKeyToFile</span><span class="params">(String algorithm, String pubPath, String priPath)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取密钥对生成器</span></span><br><span class="line">        <span class="type">KeyPairGenerator</span> <span class="variable">keyPairGenerator</span> <span class="operator">=</span> KeyPairGenerator.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 获取密钥对</span></span><br><span class="line">        <span class="type">KeyPair</span> <span class="variable">keyPair</span> <span class="operator">=</span> keyPairGenerator.generateKeyPair();</span><br><span class="line">        <span class="comment">// 获取公钥</span></span><br><span class="line">        <span class="type">PublicKey</span> <span class="variable">publicKey</span> <span class="operator">=</span> keyPair.getPublic();</span><br><span class="line">        <span class="comment">// 获取私钥</span></span><br><span class="line">        <span class="type">PrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> keyPair.getPrivate();</span><br><span class="line">        <span class="comment">// 获取byte数组</span></span><br><span class="line">        <span class="type">byte</span>[] publicKeyEncoded = publicKey.getEncoded();</span><br><span class="line">        <span class="type">byte</span>[] privateKeyEncoded = privateKey.getEncoded();</span><br><span class="line">        <span class="comment">// 进行Base64编码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">publicKeyString</span> <span class="operator">=</span> Base64.encode(publicKeyEncoded);</span><br><span class="line">        <span class="type">String</span> <span class="variable">privateKeyString</span> <span class="operator">=</span> Base64.encode(privateKeyEncoded);</span><br><span class="line">        <span class="comment">// 保存文件</span></span><br><span class="line">        FileUtils.writeStringToFile(<span class="keyword">new</span> <span class="title class_">File</span>(pubPath), publicKeyString, Charset.forName(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        FileUtils.writeStringToFile(<span class="keyword">new</span> <span class="title class_">File</span>(priPath), privateKeyString, Charset.forName(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> algorithm      : 算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encrypted      : 密文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key            : 密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> : 原文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">decryptRSA</span><span class="params">(String algorithm,Key key,String encrypted)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">         <span class="comment">// 创建加密对象</span></span><br><span class="line">        <span class="comment">// 参数表示加密算法</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 私钥进行解密</span></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE,key);</span><br><span class="line">        <span class="comment">// 由于密文进行了Base64编码, 在这里需要进行解码</span></span><br><span class="line">        <span class="type">byte</span>[] decode = Base64.decode(encrypted);</span><br><span class="line">        <span class="comment">// 对密文进行解密，不需要使用base64，因为原文不会乱码</span></span><br><span class="line">        <span class="type">byte</span>[] bytes1 = cipher.doFinal(decode);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用密钥加密数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> algorithm      : 算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input          : 原文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key            : 密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> : 密文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">encryptRSA</span><span class="params">(String algorithm,Key key,String input)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 创建加密对象</span></span><br><span class="line">        <span class="comment">// 参数表示加密算法</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 初始化加密</span></span><br><span class="line">        <span class="comment">// 第一个参数:加密的模式</span></span><br><span class="line">        <span class="comment">// 第二个参数：使用私钥进行加密</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE,key);</span><br><span class="line">        <span class="comment">// 私钥加密</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = cipher.doFinal(input.getBytes());</span><br><span class="line">        <span class="comment">// 对密文进行Base64编码</span></span><br><span class="line">        <span class="keyword">return</span> Base64.encode(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h1><p>数字签名（又称<a class="link"   href="https://baike.baidu.com/item/%E5%85%AC%E9%92%A5" >公钥<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>数字签名）是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。在网络中传输数据时候，给数据添加一个数字签名，表示是谁发的数据，而且还能证明数据没有被篡改。</p>
<ul>
<li>一套数字签名通常定义两种互补的运算，一个用于签名，另一个用于验证。</li>
<li>数字签名是非对称<a class="link"   href="https://baike.baidu.com/item/%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF" >密钥加密技术<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>与<a class="link"   href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E6%91%98%E8%A6%81/4069118" >数字摘要<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>技术的应用。</li>
</ul>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>张三有俩好哥们A、B。由于工作原因，张三和AB写邮件的时候为了安全都需要加密。于是张三想到了数字签名：</p>
<p>整个思路是这个样子的：</p>
<p>第一步：加密采用非对称加密，张三有三把钥匙，两把公钥，送给朋友。一把私钥留给自己。</p>
<p>第二步：A或者B写邮件给张三：A先用公钥对邮件加密，然后张三收到邮件之后使用私钥解密。</p>
<p>第三步：张三写邮件给A或者B：</p>
<p>（1）张三写完邮件，先用hash函数生成邮件的摘要，附着在文章上面，这就完成了数字签名，然后张三再使用私钥加密。就可以把邮件发出去了。</p>
<p>（2）A或者是B收到邮件之后，先把数字签名取下来，然后使用自己的公钥解密即可。这时候取下来的数字签名中的摘要若和张三的一致，那就认为是张三发来的，再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。</p>
<p>上面的流程我们使用一张图来演示一下：</p>
<p>首先把公钥送给朋友A和B：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250120164101834.png"
                      class="" title="image-20250120164101834"
                >

<p>张三给A或者B发邮件：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250120164119397.png"
                      class="" title="image-20250120164119397"
                ></p>
<h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>我们对签名进行验证时，需要用到公钥。如果公钥是伪造的，那我们无法验证数字签名了，也就根本不可能从数字签名确定对方的合法性了，这时候就要用到公钥。</p>
<p>有了这个证书后，即使张三的朋友A把公钥弄错了，张三也可以通过这个证书验证。</p>
<h3 id="证书信息"><a href="#证书信息" class="headerlink" title="证书信息"></a>证书信息</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250120165937159.png"
                      class="" title="image-20250120165937159"
                >

<h3 id="证书生成流程"><a href="#证书生成流程" class="headerlink" title="证书生成流程"></a>证书生成流程</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250120194612648.png"
                      class="" title="image-20250120194612648"
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250120194758619.png"
                      class="" title="image-20250120194758619"
                >



<blockquote>
<p>流程：Bob发送信件时，将数字签名和数字证书一起发送。拿到信件后先将数字证书里公钥获取。再通过公钥来验证信息。</p>
<p><a class="link"   href="https://www.bilibili.com/video/BV1US4y1D77m?p=10" >https://www.bilibili.com/video/BV1US4y1D77m?p=10<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
<h3 id="消息发送流程"><a href="#消息发送流程" class="headerlink" title="消息发送流程"></a>消息发送流程</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250120194742857.png"
                      class="" title="image-20250120194742857"
                >

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.security.utils.Base64;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SignatureDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">PublicKey</span> <span class="variable">publicKey</span> <span class="operator">=</span> RsaDemo.loadPublicKeyFromFile(<span class="string">&quot;RSA&quot;</span>, <span class="string">&quot;a.pub&quot;</span>);</span><br><span class="line">        <span class="type">PrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> RsaDemo.loadPrivateKeyFromFile(<span class="string">&quot;RSA&quot;</span>, <span class="string">&quot;a.pri&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">signaturedData</span> <span class="operator">=</span> getSignature(a, <span class="string">&quot;sha256withrsa&quot;</span>, privateKey);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> verifySignature(a, <span class="string">&quot;sha256withrsa&quot;</span>, publicKey, signaturedData);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成签名</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input      : 原文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> algorithm  : 算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey : 私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> : 签名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getSignature</span><span class="params">(String input, String algorithm, PrivateKey privateKey)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取签名对象</span></span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> Signature.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 初始化签名</span></span><br><span class="line">        signature.initSign(privateKey);</span><br><span class="line">        <span class="comment">// 传入原文</span></span><br><span class="line">        signature.update(input.getBytes());</span><br><span class="line">        <span class="comment">// 开始签名</span></span><br><span class="line">        <span class="type">byte</span>[] sign = signature.sign();</span><br><span class="line">        <span class="comment">// 对签名数据进行Base64编码</span></span><br><span class="line">        <span class="keyword">return</span> Base64.encode(sign);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验签名</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input          : 原文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> algorithm      : 算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey      : 公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> signaturedData : 签名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> : 数据是否被篡改</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">verifySignature</span><span class="params">(String input, String algorithm, PublicKey publicKey, String signaturedData)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取签名对象</span></span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> Signature.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 初始化签名</span></span><br><span class="line">        signature.initVerify(publicKey);</span><br><span class="line">        <span class="comment">// 传入原文</span></span><br><span class="line">        signature.update(input.getBytes());</span><br><span class="line">        <span class="comment">// 校验数据</span></span><br><span class="line">        <span class="keyword">return</span> signature.verify(Base64.decode(signaturedData));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Https"><a href="#Https" class="headerlink" title="Https"></a>Https</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250120194724596.png"
                      class="" title="image-20250120194724596"
                >

<h2 id="Keytool工具"><a href="#Keytool工具" class="headerlink" title="Keytool工具"></a>Keytool工具</h2><p>Keytool 是一个java提供的证书管理工具</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">-alias：密钥的别名 </span><br><span class="line">-keyalg：使用的hash算法 </span><br><span class="line">-keypass：密钥的访问密码 </span><br><span class="line">-keystore：密钥库文件名，xc.keystore保存了生成的证书 </span><br><span class="line">-storepass：密钥库的访问密码 </span><br></pre></td></tr></table></figure></div>

<p>keytool工具路径：<code>C:\Program Files\Java\jre1.8.0_91\bin</code></p>
<ul>
<li><p>生成密钥证书 下边命令生成密钥证书，采用RSA 算法每个证书包含公钥和私钥。</p>
<p>创建一个文件夹，在该文件夹下执行如下命令行：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">keytool -genkeypair -alias asjm -keyalg RSA -keypass asjm -keystore asjm.jks -storepass asjm </span><br></pre></td></tr></table></figure></div>
</li>
<li><p>查询证书信息</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">keytool -list -keystore asjm.jks</span><br></pre></td></tr></table></figure></div>

<p>删除别名</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">keytool -delete -alias asjm -keystore asjm.jsk</span><br></pre></td></tr></table></figure></div></li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250120195642268.png"
                      class="" title="image-20250120195642268"
                >

<p><strong>常用命令：</strong></p>
<blockquote>
<p>生成keypair<br>keytool -genkeypair<br>keytool -genkeypair -alias lisi（后面部分是为证书指定别名，否则采用默认的名称为mykey）</p>
<p>看看keystore中有哪些项目：<br>keytool -list或keytool -list -v<br>keytool -exportcert -alias lisi -file lisi.cer</p>
<p>生成可打印的证书：<br>keytool -exportcert -alias lisi -file lisi.cer –rfc</p>
<p>显示数字证书文件中的证书信息：<br>keytool -printcert -file lisi.cer<br>直接双击lisi.cer，用window系统的内置程序打开lisi.cer</p>
</blockquote>
<h2 id="导出公钥"><a href="#导出公钥" class="headerlink" title="导出公钥"></a>导出公钥</h2><p>openssl是一个加解密工具包，这里使用openssl来导出公钥信息。</p>
<p>安装 openssl：<code>http://slproweb.com/products/Win32OpenSSL.html</code></p>
<p>安装资料目录下的Win64OpenSSL-1_1_0g.exe</p>
<p>配置openssl的path环境变量，如下图：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/image-20250120200809728.png"
                      class="" title="image-20250120200809728"
                >

<p>cmd进入asjm.jks文件所在目录执行如下命令(如下命令在windows下执行，会把-变成中文方式，改成英文的-)：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">keytool -list -rfc --keystore asjm.jks | openssl x509 -inform pem -pubkey</span><br></pre></td></tr></table></figure></div>

<p>下面段内容是公钥</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvFsEiaLvij9C1Mz+oyAm</span><br><span class="line">t47whAaRkRu/8kePM+X8760UGU0RMwGti6Z9y3LQ0RvK6I0brXmbGB/RsN38PVnh</span><br><span class="line">cP8ZfxGUH26kX0RK+tlrxcrG+HkPYOH4XPAL8Q1lu1n9x3tLcIPxq8ZZtuIyKYEm</span><br><span class="line">oLKyMsvTviG5flTpDprT25unWgE4md1kthRWXOnfWHATVY7Y/r4obiOL1mS5bEa/</span><br><span class="line">iNKotQNnvIAKtjBM4RlIDWMa6dmz+lHtLtqDD2LF1qwoiSIHI75LQZ/CNYaHCfZS</span><br><span class="line">xtOydpNKq8eb1/PGiLNolD4La2zf0/1dlcr5mkesV570NxRmU1tFm8Zd3MZlZmyv</span><br><span class="line">9QIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure></div>

<p>将上边的公钥拷贝到文本public.key文件中，合并为一行,可以将它放到需要实现授权认证的工程中</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/wps1.jpg"
                      class="" title="img"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/wps2.jpg"
                      class="" title="img"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/wps3.jpg"
                      class="" title="img"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/wps4.jpg"
                      class="" title="img"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2023/09/17/%E5%AF%86%E7%A0%81%E5%AD%A6/wps5.jpg"
                      class="" title="img"
                >





<h1 id="附加："><a href="#附加：" class="headerlink" title="附加："></a>附加：</h1><h2 id="RsaDemo"><a href="#RsaDemo" class="headerlink" title="RsaDemo"></a>RsaDemo</h2><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.asjm.encryptcase.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.security.utils.Base64;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.X509EncodedKeySpec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RsaDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        generateKeyToFile(<span class="string">&quot;RSA&quot;</span>, <span class="string">&quot;a.pub&quot;</span>, <span class="string">&quot;a.pri&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成密钥对并保存在本地文件中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> algorithm : 算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pubPath   : 公钥保存路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> priPath   : 私钥保存路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">generateKeyToFile</span><span class="params">(String algorithm, String pubPath, String priPath)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取密钥对生成器</span></span><br><span class="line">        <span class="type">KeyPairGenerator</span> <span class="variable">keyPairGenerator</span> <span class="operator">=</span> KeyPairGenerator.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 获取密钥对</span></span><br><span class="line">        <span class="type">KeyPair</span> <span class="variable">keyPair</span> <span class="operator">=</span> keyPairGenerator.generateKeyPair();</span><br><span class="line">        <span class="comment">// 获取公钥</span></span><br><span class="line">        <span class="type">PublicKey</span> <span class="variable">publicKey</span> <span class="operator">=</span> keyPair.getPublic();</span><br><span class="line">        <span class="comment">// 获取私钥</span></span><br><span class="line">        <span class="type">PrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> keyPair.getPrivate();</span><br><span class="line">        <span class="comment">// 获取byte数组</span></span><br><span class="line">        <span class="type">byte</span>[] publicKeyEncoded = publicKey.getEncoded();</span><br><span class="line">        <span class="type">byte</span>[] privateKeyEncoded = privateKey.getEncoded();</span><br><span class="line">        <span class="comment">// 进行Base64编码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">publicKeyString</span> <span class="operator">=</span> Base64.encode(publicKeyEncoded);</span><br><span class="line">        <span class="type">String</span> <span class="variable">privateKeyString</span> <span class="operator">=</span> Base64.encode(privateKeyEncoded);</span><br><span class="line">        <span class="comment">// 保存文件</span></span><br><span class="line">        FileUtils.writeStringToFile(<span class="keyword">new</span> <span class="title class_">File</span>(pubPath), publicKeyString, Charset.forName(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        FileUtils.writeStringToFile(<span class="keyword">new</span> <span class="title class_">File</span>(priPath), privateKeyString, Charset.forName(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从文件中加载公钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> algorithm : 算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath  : 文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> : 公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PublicKey <span class="title function_">loadPublicKeyFromFile</span><span class="params">(String algorithm, String filePath)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 将文件内容转为字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">keyString</span> <span class="operator">=</span> FileUtils.readFileToString(<span class="keyword">new</span> <span class="title class_">File</span>(filePath), Charset.forName(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> loadPublicKeyFromString(algorithm, keyString);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从字符串中加载公钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> algorithm : 算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyString : 公钥字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> : 公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PublicKey <span class="title function_">loadPublicKeyFromString</span><span class="params">(String algorithm, String keyString)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 进行Base64解码</span></span><br><span class="line">        <span class="type">byte</span>[] decode = Base64.decode(keyString);</span><br><span class="line">        <span class="comment">// 获取密钥工厂</span></span><br><span class="line">        <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 构建密钥规范</span></span><br><span class="line">        <span class="type">X509EncodedKeySpec</span> <span class="variable">keyspec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X509EncodedKeySpec</span>(decode);</span><br><span class="line">        <span class="comment">// 获取公钥</span></span><br><span class="line">        <span class="keyword">return</span> keyFactory.generatePublic(keyspec);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从文件中加载私钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> algorithm : 算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath  : 文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> : 私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PrivateKey <span class="title function_">loadPrivateKeyFromFile</span><span class="params">(String algorithm, String filePath)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 将文件内容转为字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">keyString</span> <span class="operator">=</span> FileUtils.readFileToString(<span class="keyword">new</span> <span class="title class_">File</span>(filePath), Charset.forName(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> loadPrivateKeyFromString(algorithm, keyString);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从字符串中加载私钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> algorithm : 算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyString : 私钥字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> : 私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PrivateKey <span class="title function_">loadPrivateKeyFromString</span><span class="params">(String algorithm, String keyString)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 进行Base64解码</span></span><br><span class="line">        <span class="type">byte</span>[] decode = Base64.decode(keyString);</span><br><span class="line">        <span class="comment">// 获取密钥工厂</span></span><br><span class="line">        <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 构建密钥规范</span></span><br><span class="line">        <span class="type">PKCS8EncodedKeySpec</span> <span class="variable">keyspec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PKCS8EncodedKeySpec</span>(decode);</span><br><span class="line">        <span class="comment">// 生成私钥</span></span><br><span class="line">        <span class="keyword">return</span> keyFactory.generatePrivate(keyspec);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用密钥加密数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> algorithm      : 算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input          : 原文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key            : 密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxEncryptSize : 最大加密长度(需要根据实际情况进行调整)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> : 密文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">encrypt</span><span class="params">(String algorithm, String input, Key key, <span class="type">int</span> maxEncryptSize)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取Cipher对象</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 初始化模式(加密)和密钥</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, key);</span><br><span class="line">        <span class="comment">// 将原文转为byte数组</span></span><br><span class="line">        <span class="type">byte</span>[] data = input.getBytes();</span><br><span class="line">        <span class="comment">// 总数据长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> data.length;</span><br><span class="line">        <span class="comment">// 输出流</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        decodeByte(maxEncryptSize, cipher, data, total, baos);</span><br><span class="line">        <span class="comment">// 对密文进行Base64编码</span></span><br><span class="line">        <span class="keyword">return</span> Base64.encode(baos.toByteArray());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> algorithm      : 算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encrypted      : 密文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key            : 密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxDecryptSize : 最大解密长度(需要根据实际情况进行调整)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> : 原文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">decrypt</span><span class="params">(String algorithm, String encrypted, Key key, <span class="type">int</span> maxDecryptSize)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取Cipher对象</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 初始化模式(解密)和密钥</span></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, key);</span><br><span class="line">        <span class="comment">// 由于密文进行了Base64编码, 在这里需要进行解码</span></span><br><span class="line">        <span class="type">byte</span>[] data = Base64.decode(encrypted);</span><br><span class="line">        <span class="comment">// 总数据长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> data.length;</span><br><span class="line">        <span class="comment">// 输出流</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"></span><br><span class="line">        decodeByte(maxDecryptSize, cipher, data, total, baos);</span><br><span class="line">        <span class="comment">// 输出原文</span></span><br><span class="line">        <span class="keyword">return</span> baos.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分段处理数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxSize : 最大处理能力</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cipher  : Cipher对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data    : 要处理的byte数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> total   : 总数据长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> baos    : 输出流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">decodeByte</span><span class="params">(<span class="type">int</span> maxSize, Cipher cipher, <span class="type">byte</span>[] data, <span class="type">int</span> total, ByteArrayOutputStream baos)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 偏移量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 缓冲区</span></span><br><span class="line">        <span class="type">byte</span>[] buffer;</span><br><span class="line">        <span class="comment">// 如果数据没有处理完, 就一直继续</span></span><br><span class="line">        <span class="keyword">while</span> (total - offset &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果剩余的数据 &gt;= 最大处理能力, 就按照最大处理能力来加密数据</span></span><br><span class="line">            <span class="keyword">if</span> (total - offset &gt;= maxSize) &#123;</span><br><span class="line">                <span class="comment">// 加密数据</span></span><br><span class="line">                buffer = cipher.doFinal(data, offset, maxSize);</span><br><span class="line">                <span class="comment">// 偏移量向右侧偏移最大数据能力个</span></span><br><span class="line">                offset += maxSize;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果剩余的数据 &lt; 最大处理能力, 就按照剩余的个数来加密数据</span></span><br><span class="line">                buffer = cipher.doFinal(data, offset, total - offset);</span><br><span class="line">                <span class="comment">// 偏移量设置为总数据长度, 这样可以跳出循环</span></span><br><span class="line">                offset = total;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向输出流写入数据</span></span><br><span class="line">            baos.write(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="SignatureDemo"><a href="#SignatureDemo" class="headerlink" title="SignatureDemo"></a>SignatureDemo</h2><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.asjm.encryptcase.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.security.utils.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.PrivateKey;</span><br><span class="line"><span class="keyword">import</span> java.security.PublicKey;</span><br><span class="line"><span class="keyword">import</span> java.security.Signature;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SignatureDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">         <span class="comment">// 6999:表示购物的价格</span></span><br><span class="line">        <span class="comment">// 10:表示购物的数量</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;6999&quot;</span> + <span class="string">&quot;10&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">PublicKey</span> <span class="variable">publicKey</span> <span class="operator">=</span> RsaDemo.loadPublicKeyFromFile(<span class="string">&quot;RSA&quot;</span>, <span class="string">&quot;a.pub&quot;</span>);</span><br><span class="line">        <span class="type">PrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> RsaDemo.loadPrivateKeyFromFile(<span class="string">&quot;RSA&quot;</span>, <span class="string">&quot;a.pri&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">signaturedData</span> <span class="operator">=</span> getSignature(a, <span class="string">&quot;sha256withrsa&quot;</span>, privateKey);</span><br><span class="line"></span><br><span class="line">        System.out.println(signaturedData);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成签名</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input      : 原文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> algorithm  : 算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey : 私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> : 签名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getSignature</span><span class="params">(String input, String algorithm, PrivateKey privateKey)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取签名对象</span></span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> Signature.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 初始化签名</span></span><br><span class="line">        signature.initSign(privateKey);</span><br><span class="line">        <span class="comment">// 传入原文</span></span><br><span class="line">        signature.update(input.getBytes());</span><br><span class="line">        <span class="comment">// 开始签名</span></span><br><span class="line">        <span class="type">byte</span>[] sign = signature.sign();</span><br><span class="line">        <span class="comment">// 对签名数据进行Base64编码</span></span><br><span class="line">        <span class="keyword">return</span> Base64.encode(sign);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验签名</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input          : 原文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> algorithm      : 算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey      : 公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> signaturedData : 签名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> : 数据是否被篡改</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">verifySignature</span><span class="params">(String input, String algorithm, PublicKey publicKey, String signaturedData)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取签名对象</span></span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> Signature.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 初始化签名</span></span><br><span class="line">        signature.initVerify(publicKey);</span><br><span class="line">        <span class="comment">// 传入原文</span></span><br><span class="line">        signature.update(input.getBytes());</span><br><span class="line">        <span class="comment">// 校验数据</span></span><br><span class="line">        <span class="keyword">return</span> signature.verify(Base64.decode(signaturedData));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>计算机知识</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
</search>
